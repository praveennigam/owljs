<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Odoo Architecture Overview</title>

  <!-- Include Prism.js CSS for syntax highlighting -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 10px;
      background-color: #fafafa;
      color: #333;
    }

    h1,
    h2 {
      color: #3f51b5;
    }

    .content {
      background-color: #fff;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    .highlight {
      background-color: #e8f4ff;
      padding: 10px;
      border-radius: 3px;
      border: 1px solid #bbb;
    }

    .section-title {
      color: #4caf50;
      font-size: 24px;
      font-weight: bold;
    }

    .subsection-title {
      color: #ff9800;
      font-size: 20px;
      font-weight: bold;
    }

    .important {
      font-weight: bold;
      color: #ff5722;
    }

    ul {
      color: #607d8b;
    }

    /* Styling for other elements */
    code {
      font-family: 'Courier New', Courier, monospace;
      background-color: #f5f5f5;
      padding: 4px;
      border-radius: 4px;
      color: #d6336c;
    }

    pre {
      background-color: #2d2d2d;
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
      font-size: 16px;
      color: #dcdcdc;
      border: 1px solid #444;
    }
  </style>

  <!-- Include Prism.js for syntax highlighting -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-xml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
</head>






<body>

  <div
    style="font-family: 'Arial', sans-serif; margin: 0; padding: 20px; background: linear-gradient(135deg, #f06, #ffcc00); color: #333;">
    <div
      style="max-width: 800px; margin: 0 auto; background-color: #fff; padding: 30px; border-radius: 10px; box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1); text-align: center;">

      <!-- Title with Gradient Animation -->
      <h1
        style="background: linear-gradient(45deg, #2e0c64, #ffcc00, #4caf50, #3f51b5); -webkit-background-clip: text; color: transparent; font-size: 3rem; animation: gradient-animation 3s ease infinite; margin-bottom: 30px;">
        Owl JS Overview
      </h1>

      <!-- Author -->
      <p style="font-size: 1.1rem; margin-bottom: 15px;">
        <strong style="color: #4caf50;">Author:</strong> <span
          style="background: linear-gradient(45deg, #fd173d,  #5f70ed, #c1f442); -webkit-background-clip: text; color: transparent;  font-weight: 900; animation: gradient-animation 3s ease infinite;">
          Praveen Nigam </span>
      </p>

      <!-- Subject -->
      <p style="font-size: 1.1rem; margin-bottom: 15px;">
        <strong style="color: #4caf50;">Subject:</strong>
        <span
          style="background: linear-gradient(45deg, #89c644,  #e45959, #3f51b5); -webkit-background-clip: text; color: transparent;  font-weight: 900; animation: gradient-animation 3s ease infinite;">
          Owl JS</span>
      </p>

      <!-- Links -->
      <div style="margin-bottom: 30px;">
        <p style="font-size: 1.1rem;">
          <strong>Link 1:</strong>
          <a href="https://impraveen.onrender.com"
            style="background: linear-gradient(45deg, #2e0c64, #ffcc00, #851313, #3f51b5); -webkit-background-clip: text; color: transparent;  font-weight: 900; animation: gradient-animation 3s ease infinite;"
            onmouseover="this.style.color='#ff5722';" onmouseout="this.style.color='#3f51b5';">
            impraveen.onrender.com
          </a>
        </p>

        <p style="font-size: 1.1rem;">
          <strong>Link 2:</strong>
          <a href="https://youtube.com/@thewebseller?si=2Z9pOIQRTYNrFiP5"
            style="color: #3f51b5; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"
            onmouseover="this.style.color='#ff5722';" onmouseout="this.style.color='#3f51b5';">
            YouTube
          </a>
        </p>
      </div>

    </div>

    <style>
      /* Animated gradient effect for the title */
      @keyframes gradient-animation {
        0% {
          background-position: 0% 50%;
        }

        50% {
          background-position: 100% 50%;
        }

        100% {
          background-position: 0% 50%;
        }
      }

      /* Animated background gradient for the heading */
      h1 {
        background-size: 400% 400%;
        animation: gradient-animation 3s ease infinite;
      }

      /* Subtle hover effect for links */
      a:hover {
        text-decoration: underline;
        color: #ff5722;
      }
    </style>
  </div>





















  <div class="content">
    <h1 class="section-title">1. Odoo Architecture Overview</h1>
    <p>Odoo ek ERP (Enterprise Resource Planning) system hai jo modular architecture par kaam karta hai. Matlab, har ek
      functionality ko ek module ke roop mein define kiya jata hai (for example: Sales, Accounting, Inventory, etc.).
      Odoo ka core architecture Model-View-Controller (MVC) pattern par based hai.</p>

    <ul>
      <li><strong>Model:</strong> Data ko represent karta hai, aur business logic ko handle karta hai.</li>
      <li><strong>View:</strong> User Interface (UI) ko define karta hai, jo user ko data dikhata hai.</li>
      <li><strong>Controller:</strong> User actions ko handle karta hai aur appropriate responses deta hai.</li>
    </ul>

    <h2 class="subsection-title">2. Model-View-Controller (MVC) in Odoo</h2>

    <p><strong>Model (Data aur Business Logic):</strong> Model, data ko define karta hai aur database se interact karta
      hai. Odoo mein, models Python mein likhe jaate hain aur ORM (Object Relational Mapping) ka use karke database ke
      sath interact karte hain. ORM hume SQL queries likhne ki zarurat nahi padti, kyunki hum Python ki methods ka use
      karte hain jo automatically SQL queries generate kar deti hain.</p>

    <pre><code class="language-python">
    from odoo import models, fields
    
    class Product(models.Model):
        _name = 'product.product'  # Model ka name define karte hain jo table ka naam hai.
        
        name = fields.Char(string="Product Name")  # Product ka naam
        price = fields.Float(string="Product Price")  # Price of the product
        description = fields.Text(string="Product Description")  # Product ka description
            </code></pre>

    <p><strong>View (UI):</strong> Views user ko data kaise dikhai dega, yeh define karte hain. Views XML files mein
      likhe jaate hain aur har type ki view (Form, List, Kanban, Calendar, etc.) ko represent karte hain.</p>

    <h3 class="subsection-title">Example: List View (XML)</h3>

    <pre><code class="language-xml">
    &lt;record id="view_product_tree" model="ir.ui.view"&gt; 
        &lt;field name="name"&gt; product.tree.view&lt;/field&gt;   &lt;!-- View ka naam --&gt; 
        &lt;field name="model"&gt; product.product&lt;/field&gt;   &lt;!-- Model jo humne define kiya --&gt; 
        &lt;field name="arch" type="xml"&gt; 
            &lt;tree&gt; 
                &lt;field name="name"/&gt;   &lt;!-- Product name field --&gt; 
                &lt;field name="price"/&gt;   &lt;!-- Product price field --&gt; 
                &lt;field name="description"/&gt;   &lt;!-- Product description field --&gt; 
            &lt;/tree&gt; 
        &lt;/field&gt; 
    &lt;/record&gt; 
            </code></pre>

    <p><strong>Controller (User Actions):</strong> Controller user ke actions ko handle karta hai, jaise ki button
      click, form submit, etc. Controller Python mein likhe jaate hain aur HTTP routes ko define karte hain jo browser
      ke requests ko handle karte hain.</p>

    <pre><code class="language-python">
    from odoo import http
    
    class ProductController(http.Controller):
        @http.route('/product/details', auth='public')
        def product_details(self, **kwargs):
            products = http.request.env['product.product'].search([])  # All products ko fetch karte hain
            return http.request.render('product_template', {'products': products})  # Template render karte hain
            </code></pre>

    <h2 class="subsection-title">3. Odoo's ORM and Views (Forms, Lists, Kanban, Calendar)</h2>

    <p><strong>ORM (Object-Relational Mapping):</strong> ORM hume Python objects ke through database se interact karne
      ki suvidha deta hai. Hum directly SQL queries likhne ki jagah, Python mein CRUD operations (Create, Read, Update,
      Delete) karte hain.</p>

    <pre><code class="language-python">
    # Create a record
    product = self.env['product.product'].create({
        'name': 'New Product',
        'price': 100,
        'description': 'This is a new product.'
    })
    
    # Read records
    products = self.env['product.product'].search([('name', '=', 'New Product')])
    
    # Update a record
    product.write({'price': 120})
    
    # Delete a record
    product.unlink()
            </code></pre>

    <p><strong>Different View Types:</strong></p>
    <ul>
      <li><strong>Form View:</strong> Individual record ko show karne ke liye use hota hai.</li>
      <li><strong>List View:</strong> Multiple records ko table mein display karne ke liye use hota hai.</li>
      <li><strong>Kanban View:</strong> Cards format mein records ko show karta hai.</li>
      <li><strong>Calendar View:</strong> Time-based records ko dikhata hai (for example, events).</li>
    </ul>

    <h2 class="subsection-title">4. Odoo Server and Frontend Separation</h2>

    <p>Odoo mein Backend (jo Python mein likha gaya hai) aur Frontend (jo JavaScript/HTML mein likha gaya hai) ko
      alag-alag rakha gaya hai.</p>

    <ul>
      <li><strong>Backend:</strong> Business logic ko handle karta hai aur data ko database ke sath interact karta hai.
      </li>
      <li><strong>Frontend:</strong> User Interface ko render karta hai aur user ke interactions ko handle karta hai.
      </li>
    </ul>

    <p>Odoo ka frontend kaafi dynamic hai, aur OWL (Odoo Web Library) ka use karke JavaScript components banaye jaate
      hain jo real-time mein UI ko update karte hain.</p>

    <h2 class="subsection-title">5. Basic Python (Understanding Odoo's Backend)</h2>

    <p>Python ka use Odoo ke backend mein hota hai jisme aap models ko define karte hain, business logic implement karte
      hain, aur controllers likhte hain. Odoo ke backend ko samajhne ke liye aapko basic Python programming knowledge
      hona zaroori hai.</p>
  </div>









  <div class="content">
    <h1>Odoo Architecture Overview</h1>

    <div class="highlight">
      <h2 class="section-title">Example:</h2>
      <pre><code class="language-python">
    # SaleOrder Model Definition in Odoo
    class SaleOrder(models.Model):
        _name = 'sale.order'
        
        name = fields.Char('Order Reference')
        total_amount = fields.Float('Total Amount', compute='_compute_total_amount')
    
        def _compute_total_amount(self):
            for order in self:
                order.total_amount = sum(order.order_line.mapped('price_subtotal'))
                # This code defines a SaleOrder model, where total_amount is computed as the sum of the subtotal of the order lines.
                # This is an example of a computed field in Odoo.
                </code></pre>
    </div>

    <div class="highlight">
      <h2 class="section-title">Odoo Modules and Add-ons</h2>
      <p>Odoo ko extend karne ke liye aap modules create karte hain. Har module ek self-contained unit hota hai jisme
        models, views, actions, aur other components hote hain.</p>

      <h3 class="subsection-title">Module Structure:</h3>
      <ul>
        <li><b>Manifest File (__manifest__.py)</b>: Yeh file module ke bare mein metadata store karti hai.</li>
        <li><b>Models (Python)</b>: Yeh file database tables ko define karti hai aur business logic ko implement karti
          hai.</li>
        <li><b>Views (XML)</b>: Yeh file UI ko define karti hai.</li>
        <li><b>Security</b>: Yeh file security rules ko define karti hai (access control).</li>
      </ul>

      <h3 class="subsection-title">Example:</h3>

      <h4 class="important">Manifest File (__manifest__.py):</h4>
      <pre><code class="language-python">
    # Manifest file defining module metadata
    {
        'name': 'Custom Product Management',
        'version': '1.0',
        'depends': ['base'],
        'data': ['views/product_views.xml'],
    }
                </code></pre>

      <h4 class="important">Model (Python):</h4>
      <pre><code class="language-python">
    # Product Model Definition in Odoo
    class Product(models.Model):
        _name = 'product.product'
        name = fields.Char(string='Product Name')
        price = fields.Float(string='Price')
                </code></pre>

      <h4 class="important">View (XML):</h4>
      <pre><code class="language-xml">
    # Defining the Form View for the Product Model
    &lt;record id="view_product_form" model="ir.ui.view"&gt;
        &lt;field name="name"&gt; product.form.view&lt;/field&gt;
        &lt;field name="model"&gt; product.product&lt;/field&gt;
        &lt;field name="arch" type="xml"&gt;
            &lt;form string="Product"&gt;
                &lt;field name="name"/&gt;
                &lt;field name="price"/&gt;
            &lt;/form&gt;
        &lt;/field&gt;
    &lt;/record&gt;
                </code></pre>
    </div>

    <div class="highlight">
      <h2 class="section-title">Defining Models, Views, Actions, and Security in Odoo</h2>

      <h3 class="subsection-title">Models:</h3>
      <p>Models data ko represent karte hain aur database ke sath interact karte hain. Jaise ki humne Product model mein
        kiya tha.</p>

      <h3 class="subsection-title">Views:</h3>
      <p>Views UI ko define karte hain aur har view ko XML mein likhna padta hai. Jaise ki humne Form View aur List View
        define kiye.</p>

      <h3 class="subsection-title">Actions:</h3>
      <p>Actions define karte hain ki jab user kisi particular action ko perform karta hai, toh system ko kaise respond
        karna hai. Example: Jab user Product List dekhne ka action perform kare.</p>

      <h4 class="important">Example (Action Definition):</h4>
      <pre><code class="language-xml">
    # Action definition for showing the Product List in Odoo
    &lt;record id="action_product_list" model="ir.actions.act_window"&gt;
        &lt;field name="name"&gt; Products&lt;/field&gt;
        &lt;field name="res_model"&gt; product.product&lt;/field&gt;
        &lt;field name="view_mode"&gt; tree,form&lt;/field&gt;
    &lt;/record&gt;
                </code></pre>

      <h3 class="subsection-title">Security:</h3>
      <p>Odoo modules mein security ko handle karne ke liye Access Control Lists (ACL) aur Record Rules define karte
        hain.</p>

      <h4 class="important">Example (Access Control List):</h4>
      <pre><code class="language-xml">
    # Access control for the product.product model
    &lt;record id="product_product_access" model="ir.model.access"&gt;
        &lt;field name="name"&gt; product.product access&lt;/field&gt;
        &lt;field name="model_id" ref="model_product_product"/&gt;
        &lt;field name="group_id" ref="base.group_user"/&gt;
        &lt;field name="perm_read" eval="1"/&gt;
        &lt;field name="perm_write" eval="1"/&gt;
        &lt;field name="perm_create" eval="1"/&gt;
        &lt;field name="perm_unlink" eval="0"/&gt;
    &lt;/record&gt;
                </code></pre>
    </div>

  </div>




  <div class="content">
    <h2 class="section-title">2. Introduction to Owl (Odoo Web Library)</h2>
    <p>Owl (Odoo Web Library) ek modern JavaScript framework hai jo Odoo mein frontend development ke liye use hota hai.
      Yeh reactive aur component-based architecture ka use karta hai, jo Odoo ke web interfaces ko dynamic aur
      interactive banata hai.</p>
    <p>Owl ko samajhna zaroori hai agar aap Odoo mein dynamic UI develop karna chahte hain. Yeh components ka use karke
      aap har ek UI element ko as a reusable unit bana sakte hain jo apne data aur behavior ko handle karta hai.</p>

    <h3 class="subsection-title">Key Features of OWL:</h3>
    <ul>
      <li>Component-based architecture: Har UI element ko components ke roop mein break kiya jata hai.</li>
      <li>Reactivity: Jab component ka state change hota hai, tab UI automatically update hota hai.</li>
      <li>Declarative Syntax: Aap sirf batate hain ki kya dikhana hai, aur Owl automatically usse render kar deta hai.
      </li>
      <li>Performance-focused: Yeh lightweight hota hai aur performance ko optimize karta hai.</li>
    </ul>

    <h3 class="subsection-title">OWL Components:</h3>
    <p>OWL mein har UI element ek component hota hai. Har component mein 3 important cheezein hoti hain:</p>
    <ul>
      <li><strong>State</strong>: Jo data component ke liye relevant hai.</li>
      <li><strong>Template</strong>: Jo UI ko define karta hai.</li>
      <li><strong>Methods</strong>: Jo component ke behavior ko control karte hain.</li>
    </ul>

    <h3 class="subsection-title">Step-by-Step Example: A Simple OWL Component</h3>
    <p>Hum ek simple "Hello World" component banayenge jo ek message show karega aur usko button click par update
      karega.</p>

    <h4 class="subsection-title">1. JavaScript Code (Component Definition):</h4>
    <pre><code class="language-javascript">
        /** @odoo-module **/  // Yeh Odoo-specific module ko indicate karta hai
        
        import { Component } from 'owl';  // OWL ke Component class ko import karte hain
        
        // Apna custom component class banate hain jo OWL ke Component class se inherit hota hai
        class HelloWorld extends Component {
            // State: Component ka initial data
            state = {
                message: 'Hello, Odoo!'  // Yahan pe message ka initial value set karte hain
            };
        
            // Static template property, jo template ko link karta hai
            static template = 'my_module.HelloWorldTemplate';  // Template ka naam diya gaya hai, jo XML mein define kiya jayega
        
            // Method to update the message
            updateMessage() {
                this.state.message = 'Hello, OWL!';  // Jab method call hota hai, tab message update ho jata hai
            }
        }
        
        // Component ko export karte hain taaki baaki code mein use kar sakein
        export default HelloWorld;
            </code></pre>

    <h4 class="subsection-title">Explanation:</h4>
    <ul>
      <li><strong>/** @odoo-module **/:</strong> Yeh directive batata hai ki yeh ek Odoo module hai, jo OWL framework ke
        liye hai.</li>
      <li><strong>import { Component } from 'owl';:</strong> OWL library se Component class ko import kar rahe hain.
      </li>
      <li><strong>class HelloWorld extends Component:</strong> Yeh HelloWorld class apna custom component define karti
        hai jo Component class se extend hota hai.</li>
      <li><strong>state = { message: 'Hello, Odoo!' };</strong> Yeh component ka initial state hai. Ismein ek message
        field hai jo "Hello, Odoo!" se initialize hota hai.</li>
      <li><strong>static template = 'my_module.HelloWorldTemplate';:</strong> Yeh line template ko link kar rahi hai jo
        XML mein define hota hai.</li>
      <li><strong>updateMessage():</strong> Yeh method message ko update karta hai jab user button click karta hai.</li>
    </ul>

    <h4 class="subsection-title">2. XML Template (UI):</h4>
    <p>OWL mein UI ko define karne ke liye XML ka use hota hai. Template ek tarah se HTML structure ko define karta hai,
      lekin yeh reactive hota hai.</p>

    <pre><code class="language-xml">
        &lt;t t-name="my_module.HelloWorldTemplate"&gt; 
          &lt;div&gt; 
            &lt;!-- Yahan pe component ki state message ko dynamically render karenge --&gt; 
            &lt;h1 t-esc="state.message"/&gt;   &lt;!-- t-esc directive use karke message display hota hai --&gt; 
        
            &lt;!-- Button jo message ko update karega --&gt; 
            &lt;button t-on-click="updateMessage"&gt; Change Message&lt;/button&gt;  &lt;!-- Button pe click karne pe updateMessage method call hoga --&gt; 
          &lt;/div&gt; 
        &lt;/t&gt;
            </code></pre>

    <h4 class="subsection-title">Explanation:</h4>
    <ul>
      <li><strong>&lt;t t-name="my_module.HelloWorldTemplate"&gt;:</strong> Yeh template ka naam define karta hai.
        t-name attribute se template ko ek unique identifier diya jata hai.</li>
      <li><strong>&lt;h1 t-esc="state.message"/&gt;:</strong> Yeh line component ke state.message ko render kar rahi
        hai. t-esc directive dynamically data ko UI mein display karta hai.</li>
      <li><strong>&lt;button t-on-click="updateMessage"&gt;:</strong> Yeh button user interaction ko handle karta hai.
        Jab user button pe click karega, tab updateMessage() method call hoga jo state ko update karega.</li>
    </ul>

    <h3 class="subsection-title">Reactivity in OWL:</h3>
    <p>OWL mein reactivity ka concept hai. Matlab jab component ke state mein koi change hota hai, toh UI automatically
      update ho jata hai, bina page ko reload kiye. Jaise hi hum state.message ko update karenge, template automatically
      re-render ho jayega.</p>
  </div>





























































  <div class="content">

    <h1>Basic Concepts of OWL (Odoo Web Library)</h1>
    <p>
      OWL (Odoo Web Library) ek lightweight JavaScript framework hai, jo Odoo ke frontend ko handle karta hai. OWL ko
      primarily Odoo 14 ke baad use kiya gaya tha, aur isse Odoo apps mein front-end functionality ko modular aur
      reactive
      tarike se implement kiya jata hai.
    </p>
    <p>
      OWL ke through, aap components create kar sakte hain jo UI ko manage karte hain, state aur actions ko handle karte
      hain,
      aur backend ke saath communication ko asaan banate hain.
    </p>

    <h2>Components in OWL</h2>
    <p>
      OWL mein components ek fundamental concept hain. Components basically re-usable units hain jo apne logic, state,
      aur
      rendering ko encapsulate karte hain. Components aapke UI ko manage karte hain, aur inmein state, actions,
      lifecycle
      methods, aur UI rendering hoti hai.
    </p>

    <h3>What are Components in OWL?</h3>
    <p>
      Components ko aap UI elements ya behavior ko define karne ke liye use karte hain. Har component apna state,
      methods, aur
      rendering logic rakhta hai. Components ko render kiya jata hai, aur jab component ka state change hota hai, toh
      woh re-render
      hota hai. Components ko aap as JavaScript classes define karte hain, jo Owl ki Component class ko extend karte
      hain.
    </p>

    <h3>Creating a Basic Component in OWL</h3>
    <p>
      OWL mein ek simple component create karna kaafi straightforward hai. Hum ek counter component banayenge, jisme ek
      button
      hoga jo click karne par count ko increment karega.
    </p>

    <h4>1. Basic Component Example (Counter Component)</h4>
    <pre>
      <code class="language-javascript">
  // static/src/counter_component.js
  import { Component, useState } from "owl";
  
  class Counter extends Component {
    // Setup hook mein state initialize karte hain
    setup() {
      // useState hook ka use karke counter ko initialize karte hain
      this.count = useState(0);
    }
  
    // Method to increment the counter
    increment() {
      this.count += 1; // Counter ko increment karna
    }
  
    // Render method, jo UI ko return karega
    render() {
      return `
        <div>
          <p>Counter: <t t-esc="count" /></p>
          <button t-on-click="increment">Increment</button>
        </div>
      `;
    }
  }
  
  // Template ko associate karte hain
  Counter.template = 'CounterTemplate';
  export default Counter;
      </code>
    </pre>
    <p><strong>Explanation:</strong></p>
    <ul>
      <li><strong>setup():</strong> Yeh method component ke state ko define karta hai. Hum yahan useState(0) ka use
        karte hain jisse count ki initial value 0 hogi.</li>
      <li><strong>increment():</strong> Yeh method count ko increment karta hai. Jab button click hota hai, tab
        increment() method call hota hai, aur count value ko 1 se badha diya jata hai.</li>
      <li><strong>render():</strong> Yeh method UI ko define karta hai. Hum yahan ek p tag mein current count ko show
        kar rahe hain aur ek button add kiya hai jisme t-on-click directive hai, jo button ke click hone par increment()
        method ko call karega.</li>
    </ul>

    <h4>2. Component Template (In Odoo)</h4>
    <p>
      Template ko Odoo mein manage karne ke liye aapko XML file ki zarurat hoti hai. Template ko HTML jaisa hi likha
      jata hai,
      jisme Owl directives jaise t-esc aur t-on-click ka use hota hai.
    </p>
    <pre>
      <code class="language-xml">
  &lt;!-- static/src/xml/counter_template.xml --&gt;
  &lt;odoo&gt;
    &lt;template id="CounterTemplate"&gt;
      &lt;div&gt;
        &lt;p&gt;Counter: 
          &lt;t t-esc="component.count" /&gt;
        &lt;/p&gt;
        &lt;button t-on-click="component.increment"&gt;Increment&lt;/button&gt;
      &lt;/div&gt;
    &lt;/template&gt;
  &lt;/odoo&gt;
      </code>
    </pre>
    <p>
      <strong>t-esc="component.count":</strong> Yeh directive counter ki value ko dynamically display karta hai.
      <strong>t-on-click="component.increment":</strong> Yeh button click hone par increment() method ko call karega.
    </p>

    <h3>Rendering Components in OWL</h3>
    <p>
      Components ko render karna OWL mein kaafi simple hai. Aapko bas component ko ek root DOM element mein render karna
      hota
      hai.
    </p>

    <h4>1. Rendering the Component in a Web Page:</h4>
    <pre>
      <code class="language-javascript">
  // static/src/main.js
  import { mount } from "owl";
  import Counter from "./counter_component";
  
  // Yahan component ko ek div element mein render kar rahe hain
  mount(Counter, {
    target: document.getElementById("counter-container"), // Yahan DOM target define karte hain
  });
      </code>
    </pre>
    <p><strong>mount():</strong> Yeh function component ko ek HTML DOM element ke saath associate karta hai. Jab Counter
      component ko mount kiya jata hai, woh target element mein render ho jata hai.</p>

    <h4>2. HTML Template for Mounting the Component:</h4>
    <pre>
      <code class="language-xml">
  &lt;!-- static/src/index.html --&gt;
  &lt;!DOCTYPE html&gt;
  &lt;html lang="en"&gt;
  
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;OWL Counter Example&lt;/title&gt;
  &lt;/head&gt;
  
  &lt;body&gt;
    &lt;div id="counter-container"&gt;&lt;/div&gt;
  
    &lt;script src="/static/src/main.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
  
  &lt;/html&gt;
      </code>
    </pre>
    <p>
      <strong>&lt;div id="counter-container"&gt;&lt;/div&gt;:</strong> Yeh div element hai, jahan aap Counter component
      ko render karenge.
    </p>

    <h3>Complete Example in Odoo Module</h3>
    <p>
      Jab aap OWL components ko Odoo module mein use karte hain, toh aapko apne assets aur template files ko properly
      configure karna padta hai.
    </p>

    <h4>Module Manifest (__manifest__.py)</h4>
    <pre>
      <code class="language-python">
  {
    'name': 'Counter Example Module',
    'version': '1.0',
    'depends': ['web'],
    'data': [
      'views/counter_template.xml',
    ],
    'assets': {
      'web.assets_frontend': [
        'my_module/static/src/counter_component.js',
        'my_module/static/src/main.js',
      ],
    },
  }
      </code>
    </pre>

    <h4>Template File (counter_template.xml)</h4>
    <pre>
      <code class="language-xml">
  &lt;odoo&gt;
    &lt;template id="CounterTemplate"&gt;
      &lt;div&gt;
        &lt;p&gt;Counter:
          &lt;t t-esc="component.count" /&gt;
        &lt;/p&gt;
        &lt;button t-on-click="component.increment"&gt;Increment&lt;/button&gt;
      &lt;/div&gt;
    &lt;/template&gt;
  &lt;/odoo&gt;
      </code>
    </pre>

    <h4>Main JavaScript File (main.js)</h4>
    <pre>
      <code class="language-javascript">
  import { mount } from "owl";
  import Counter from "./counter_component";
  
  mount(Counter, {
    target: document.getElementById("counter-container"),
  });
      </code>
    </pre>


    <h1>Owl JS Lifecycle Hooks in Odoo</h1>
    <p>
      Owl JS, jo ki Odoo ka web framework hai, components ko manage karne ke liye lifecycle hooks provide karta hai. Ye
      hooks
      aapko component ke different phases mein help karte hain, jaise ki initialization, rendering, updates, aur
      cleanup. In
      hooks ka use kar ke aap apne Odoo components ko better tarike se manage kar sakte hain.
    </p>
    <p>
      Ab hum in lifecycle hooks ko detail mein samjhenge, aur har ek hook ko real-world Odoo example ke saath explain
      karenge.
    </p>

    <h2>1. setup() Hook</h2>
    <h3>Purpose:</h3>
    <p>
      Ye hook component ko initialize karta hai aur state set karta hai. Jab component render hona start hota hai, tab
      setup()
      run hota hai.
    </p>
    <h3>Use Case:</h3>
    <p>
      Aap state set kar sakte hain, ya phir reusable logic yahan likh sakte hain. Jaise, agar aapko kisi variable ki
      initial
      value deni ho ya kisi dependency ko set karna ho.
    </p>
    <h3>Example:</h3>
    <pre>
      <code class="language-javascript">
  // file: CounterComponent.js
  import { Component, useState } from "@odoo/owl";
  
  export class CounterComponent extends Component {
    setup() {
      // Initial state setup
      this.state = useState({ count: 0 }); // Counter ki initial value 0 hai
    }
  
    increment() {
      this.state.count += 1; // Button click par counter increment hoga
    }
  }
      </code>
    </pre>
    <h3>XML Template:</h3>
    <pre>
      <code class="language-xml">
  &lt;template&gt;
    &lt;div&gt;
      &lt;p&gt;Count:
        &lt;t t-esc="state.count" /&gt;
      &lt;/p&gt; &lt;!-- State ke count ko render karega --&gt;
      &lt;button t-on-click="increment"&gt;Increment&lt;/button&gt; &lt;!-- Increment button --&gt;
    &lt;/div&gt;
  &lt;/template&gt;
      </code>
    </pre>
    <p>
      Yahan, setup() hook me humne state initialize kiya hai jo counter ka value rakhega.
    </p>

    <h2>2. willStart() Hook</h2>
    <h3>Purpose:</h3>
    <p>
      Ye hook component mount hone se pehle run hota hai. Agar aapko data fetch karna ho, ya kisi asynchronous task ko
      perform karna ho, toh aap willStart() ka use kar sakte hain.
    </p>
    <h3>Use Case:</h3>
    <p>
      Yahan pe aap kisi API se data fetch kar sakte hain ya kisi operation ko asynchronous tor pe handle kar sakte hain.
    </p>
    <h3>Example:</h3>
    <pre>
      <code class="language-javascript">
  // file: ProductList.js
  export class ProductList extends Component {
    async willStart() {
      // Product data fetch karte hain, taaki component render ho jane ke baad data ho
      this.products = await this.fetchProducts();
    }
  
    async fetchProducts() {
      const response = await fetch('/api/products');
      return response.json(); // Products ki list fetch kar rahe hain
    }
  }
      </code>
    </pre>
    <h3>XML Template:</h3>
    <pre>
      <code class="language-xml">
  &lt;template&gt;
    &lt;div&gt;
      &lt;ul&gt;
        &lt;li t-foreach="products" t-as="product"&gt;
          &lt;t t-esc="product.name" /&gt; &lt;!-- Product name ko display karega --&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/template&gt;
      </code>
    </pre>
    <p>
      Is example me willStart() hook ka use karke humne API se product data fetch kiya hai jo component render hone se
      pehle
      ho gaya.
    </p>

    <h2>3. willRender() Hook</h2>
    <h3>Purpose:</h3>
    <p>
      Ye hook component ke render hone se pehle run hota hai. Agar aapko kisi cheez ko modify karna ho, jaise ki state
      ko
      validate karna ya update karna, toh aap willRender() ka use kar sakte hain.
    </p>
    <h3>Use Case:</h3>
    <p>
      Aap state ya props ko modify kar sakte hain ya valid kar sakte hain before the actual render.
    </p>
    <h3>Example:</h3>
    <pre>
      <code class="language-javascript">
  // file: ProductDetails.js
  export class ProductDetails extends Component {
    willRender() {
      // Agar product ka naam nahi hai toh default set kar do
      if (!this.product.name) {
        this.product.name = 'Unknown Product'; // Default value set kar rahe hain
      }
    }
  }
      </code>
    </pre>
    <h3>XML Template:</h3>
    <pre>
      <code class="language-xml">
  &lt;template&gt;
    &lt;div&gt;
      &lt;h1&gt;
        &lt;t t-esc="product.name" /&gt;
      &lt;/h1&gt; &lt;!-- Product ka name show karega --&gt;
    &lt;/div&gt;
  &lt;/template&gt;
      </code>
    </pre>
    <p>
      Yahan humne willRender() hook me check kiya ki agar product.name empty hai toh usko default value set kar denge.
    </p>



    <h1>Owl JS Lifecycle Hooks in Odoo</h1>

    <h2>4. mounted() Hook</h2>
    <h3>Purpose:</h3>
    <p>
      Ye hook component ke DOM par mount hone ke baad run hota hai. Aap is hook mein DOM interactions ya third-party
      libraries ko initialize kar sakte hain.
    </p>
    <h3>Use Case:</h3>
    <p>
      Jaise ki input field pe focus set karna, ya kisi third-party library ka initialization.
    </p>
    <h3>Example:</h3>
    <pre>
    <code class="language-javascript">
// file: SearchBar.js
export class SearchBar extends Component {
  mounted() {
    // Input field pe focus set kar rahe hain jab component mount ho jaye
    this.el.querySelector('input').focus();
  }
}
    </code>
  </pre>
    <h3>XML Template:</h3>
    <pre>
    <code class="language-xml">
&lt;template&gt;
  &lt;div&gt;
    &lt;input type="text" placeholder="Search..." /&gt; &lt;!-- Search bar input --&gt;
  &lt;/div&gt;
&lt;/template&gt;
    </code>
  </pre>
    <p>
      Yahan, humne mounted() hook mein input field pe focus set kiya jab component DOM par mount ho gaya.
    </p>

    <h2>5. shouldUpdate() Hook</h2>
    <h3>Purpose:</h3>
    <p>
      Ye hook decide karta hai ki component ko update hona chahiye ya nahi jab state ya props change ho. Ye performance
      optimization ke liye use hota hai.
    </p>
    <h3>Use Case:</h3>
    <p>
      Agar aapko lagta hai ki component ko re-render hone ki zarurat nahi hai, toh aap shouldUpdate() hook mein logic
      laga
      sakte hain.
    </p>
    <h3>Example:</h3>
    <pre>
    <code class="language-javascript">
// file: ProductCard.js
export class ProductCard extends Component {
  shouldUpdate(nextProps) {
    // Agar product ka ID change nahi hota toh update nahi karna
    return nextProps.product.id !== this.props.product.id;
  }
}
    </code>
  </pre>

    <h2>6. willUpdateProps() Hook</h2>
    <h3>Purpose:</h3>
    <p>
      Ye hook component ke props update hone se pehle run hota hai. Aap props ko modify ya validate kar sakte hain
      before
      the update.
    </p>
    <h3>Use Case:</h3>
    <p>
      Agar aapko kisi prop ka validation ya modification karna ho before the update.
    </p>
    <h3>Example:</h3>
    <pre>
    <code class="language-javascript">
// file: ProductDetails.js
export class ProductDetails extends Component {
  willUpdateProps(nextProps) {
    // Agar product ka price invalid ho toh error show karna
    if (nextProps.product.price < 0) { 
      console.error('Invalid product price'); 
    }
  }
}
    </code>
  </pre>

    <h2>7. willPatch() Hook</h2>
    <h3>Purpose:</h3>
    <p>
      Ye hook DOM ke patch hone se pehle run hota hai. Aap changes ko modify kar sakte hain ya fine-tune kar sakte hain
      before they are applied.
    </p>
    <h3>Use Case:</h3>
    <p>
      Agar aapko patch ke changes ko manipulate karna ho, jaise ki kisi condition par update ko change karna.
    </p>
    <h3>Example:</h3>
    <pre>
    <code class="language-javascript">
// file: NotificationBanner.js
export class NotificationBanner extends Component {
  willPatch(nextState) {
    // Agar message bohot lamba ho, toh truncate kar do
    if (nextState.message.length > 100) {
      nextState.message = 'Message too long';
    }
  }
}
    </code>
  </pre>

    <h2>8. patched() Hook</h2>
    <h3>Purpose:</h3>
    <p>
      Ye hook DOM ke patch hone ke baad run hota hai. Aap post-update tasks perform kar sakte hain, jaise ki logging ya
      analytics.
    </p>
    <h3>Use Case:</h3>
    <p>
      Jab DOM update ho jata hai, toh aap post-update actions perform kar sakte hain.
    </p>
    <h3>Example:</h3>
    <pre>
    <code class="language-javascript">
// file: MessageComponent.js
export class MessageComponent extends Component {
  patched() {
    console.log('Component DOM patched successfully!');
  }
}
    </code>
  </pre>

    <h2>9. willUnmount() Hook</h2>
    <h3>Purpose:</h3>
    <p>
      Ye hook component ke DOM se remove hone se pehle run hota hai. Cleanup tasks jaise event listeners remove karna,
      timers stop karna,
      ya resources release karna yahan kiya jata hai.
    </p>
    <h3>Use Case:</h3>
    <p>
      Agar aapko event listeners ko remove karna ho ya timers ko stop karna ho jab component destroy ho jaye.
    </p>
    <h3>Example:</h3>
    <pre>
    <code class="language-javascript">
// file: TimerComponent.js
export class TimerComponent extends Component {
  setup() {
    this.timer = setInterval(() => {
      console.log('Timer is running...');
    }, 1000);
  }

  willUnmount() {
    // Cleanup: Interval ko clear kar rahe hain
    clearInterval(this.timer);
  }
}
    </code>
  </pre>

    <h2>10. captureError() Hook</h2>
    <h3>Purpose:</h3>
    <p>
      Ye hook component ke lifecycle mein kisi bhi error ko capture karta hai.
    </p>
    <h3>Use Case:</h3>
    <p>
      Agar koi error ho jati hai, toh aap usse handle kar sakte hain, log kar sakte hain, ya user ko error message show
      kar sakte hain.
    </p>
    <h3>Example:</h3>
    <pre>
    <code class="language-javascript">
// file: ErrorComponent.js
export class ErrorComponent extends Component {
  captureError(error) {
    console.error('Error in component:', error);
    // Handle the error (log it, report it, etc.)
  }
}
    </code>
  </pre>



    <h1>useContext in Owl JS</h1>

    <p>
      Owl JS mein state aur effect hooks ka istemal karke aap apne component ke lifecycle ko efficiently manage kar
      sakte hain.
      Aap context ko component ke lifecycle ke different phases mein access kar sakte hain, jaise ki setup, mounted, aur
      updated hooks.
      Is tarah se aap component ke global state ko manage karte hue uska behavior customize kar sakte hain.
    </p>

    <p>
      Aapko samjhane ke liye, hum ek real-world example lete hain, jisme hum state, effect hooks, aur context ko use
      karenge.
      Hum Odoo mein Owl JS ka use karke ek user profile ko manage karenge.
    </p>

    <h2>Project Structure:</h2>
    <pre>
    <code class="language-scss">
/your_module
/static
/src
  - user_profile.js // JavaScript file jisme Owl JS component hoga
  - context.js // Context file jo global state ko manage karegi
/views
  - templates.xml // XML file jisme UI template hoga
__manifest__.py // Module definition ke liye manifest file
    </code>
  </pre>

    <h3>1. context.js - Global State ko manage karna</h3>
    <p>
      Hum ek context banayenge jisme user profile ki information ko globally manage kiya jayega. Yeh context different
      components mein shared rahega.
    </p>
    <pre>
    <code class="language-javascript">
// static/src/context.js
import { useContext } from "owl";

// UserContext ko define karte hain jo global user information ko store karega
export const UserContext = useContext({
  userInfo: { name: '', email: '' },
});
    </code>
  </pre>

    <h3>2. user_profile.js - Component mein Context aur State ka use</h3>
    <p>
      Ab hum ek component banayenge jo UserContext ko use karega. Is component mein hum state hooks aur lifecycle hooks
      ka use karenge.
    </p>
    <pre>
    <code class="language-javascript">
// static/src/user_profile.js
import { Component, useState, useEffect } from "owl";
import { UserContext } from './context'; // Importing the global context

class UserProfile extends Component {
  // setup() hook mein state aur context ko initialize karte hain
  setup() {
    this.userInfo = useState({ name: '', email: '' });
    this.context = UserContext; // Context ko use kar rahe hain
  }

  // mounted() hook mein hum API call karte hain jab component mount ho
  async mounted() {
    await this.fetchUserData();
  }

  // API se user data fetch karne ka method
  async fetchUserData() {
    const response = await fetch('/api/user');
    const data = await response.json();

    this.context.userInfo = data; // Global context ko update karte hain
    this.userInfo.name = data.name; // Local state ko update karte hain
    this.userInfo.email = data.email; // Local state ko update karte hain
  }

  // Method to render user profile information
  getUserProfile() {
    return `Name: ${this.context.userInfo.name}, Email: ${this.context.userInfo.email}`;
  }
}

// Template ko associate karte hain
UserProfile.template = 'UserProfileTemplate';
export default UserProfile;
    </code>
  </pre>

    <h3>3. templates.xml - Template File</h3>
    <p>
      Yeh XML file aapke UI ko define karegi. Yahaan hum Owl JS template system ka use karenge taaki humare component ka
      UI render ho sake.
    </p>
    <pre>
    <code class="language-xml">
&lt;!-- views/templates.xml --&gt;
&lt;odoo&gt;
  &lt;template id="UserProfileTemplate"&gt;
    &lt;div&gt;
      &lt;h2&gt;User Profile&lt;/h2&gt;
      &lt;p t-esc="component.getUserProfile()" /&gt; &lt;!-- JavaScript method call karte hain --&gt;
    &lt;/div&gt;
  &lt;/template&gt;
&lt;/odoo&gt;
    </code>
  </pre>

    <h3>4. __manifest__.py - Module Manifest File</h3>
    <p>
      Manifest file mein hum Odoo ko batate hain ki is module ki dependencies kya hain, data files kaha hain (jaise
      templates.xml),
      aur JS assets kahan hain (jaise user_profile.js aur context.js).
    </p>
    <pre>
    <code class="language-python">
# __manifest__.py
{
  'name': 'User Profile Module',
  'version': '1.0',
  'depends': ['web'], # Web module ki dependency
  'data': [
    'views/templates.xml', # Template file ko include karte hain
  ],
  'assets': {
    'web.assets_frontend': [
      'your_module/static/src/user_profile.js', # JS file ko link kar rahe hain
      'your_module/static/src/context.js', # Context file ko link kar rahe hain
    ],
  },
}
    </code>
  </pre>

    <h3>Code ki Explanation (Comments ke saath):</h3>
    <h4>Context (context.js):</h4>
    <p>
      context.js file mein humne UserContext define kiya hai jo user ki name aur email ko global state mein store
      karega.
      Hum useContext hook ka use kar rahe hain taaki is context ko apne components mein access kiya ja sake.
    </p>

    <h4>Component (user_profile.js):</h4>
    <p>
      <b>setup()</b>: Is hook ka use hum local state ko initialize karne ke liye karte hain. Hum context ko bhi yahan
      define karte hain taaki global state ko access kiya ja sake.<br>
      <b>mounted()</b>: Jab component mount hota hai, hum API se data fetch karte hain aur global context aur local
      state ko update karte hain.<br>
      <b>getUserProfile()</b>: Is method mein hum user ke profile ko context se access karke return karte hain taaki UI
      mein display kiya ja sake.
    </p>

    <h4>Template (templates.xml):</h4>
    <p>
      Template mein hum HTML structure ko define karte hain aur Owl JS ke t-esc directive ka use karte hain taaki
      JavaScript method ko call karke dynamic content display ho sake.
    </p>

    <h4>Manifest (__manifest__.py):</h4>
    <p>
      Manifest file mein hum Odoo ko batate hain ki kis module ki dependencies hain, data files kaha se fetch karne
      hain, aur JS assets kaha se load karne hain.
    </p>

    <h3>State Aur Effect Hooks ka Use:</h3>
    <p>
      <b>State Hook (useState)</b> ka use hum local component state ko manage karne ke liye karte hain. Jaise humne
      userInfo ko store kiya hai, jisme name aur email ki information hogi.<br>
      <b>Effect Hook (useEffect)</b> ka use hum side-effects ko manage karne ke liye karte hain, jaise hum mounted()
      hook mein API call kar rahe hain.
    </p>

    <h3>Lifecycle Hooks:</h3>
    <ul>
      <li><b>setup():</b> Is hook ka use hum component ke initialization ke liye karte hain, jahan hum state aur context
        ko initialize karte hain.</li>
      <li><b>mounted():</b> Ye hook tab trigger hota hai jab component DOM mein render hota hai. Hum is hook mein API
        calls karte hain taaki data ko fetch karke state ko update kiya ja sake.</li>
      <li><b>getUserProfile():</b> Yeh ek custom method hai jo UI ko render karte waqt context se user ki information ko
        fetch karta hai.</li>
    </ul>

    <h3>Conclusion:</h3>
    <p>
      Is example mein:
    <ul>
      <li>Humne context ka use kiya hai taaki global state ko manage kiya ja sake.</li>
      <li>State aur Effect hooks ka istemal kiya gaya hai taaki data ko dynamically manage kiya ja sake aur component ki
        reactivity maintain ho sake.</li>
      <li>Lifecycle hooks ka use karke humne component ka behavior control kiya hai jaise data fetch karna, state update
        karna, etc.</li>
    </ul>
    </p>

    <p>Chaliye, ek aur real-world example lete hain jisme hum Owl JS ke state, effect, aur context hooks ko use karenge.
      Hum ek task manager banayenge, jisme tasks ko add, remove, aur update kiya ja sakta hai. Is example mein hum
      global state, local state, aur side-effects ko handle karenge.</p>



















    <h2>Project Structure</h2>
    <pre>
    <code class="language-scss">
/your_module
/static
/src
  - task_manager.js // Task Manager ka Owl JS component
  - context.js // Global state ko handle karne ke liye context
/views
  - templates.xml // Template file jisme UI render hoga
__manifest__.py // Module ka manifest file
    </code>
  </pre>

    <h3>1. context.js - Global State for Task Management</h3>
    <p>
      Hum ek context banayenge jisme tasks ki list ko globally manage kiya jayega. Yeh context different components mein
      shared rahega.
    </p>
    <pre>
    <code class="language-javascript">
// static/src/context.js
import { useContext } from "owl";

// TaskContext ko define karte hain jo global task list ko store karega
export const TaskContext = useContext({
  tasks: [],
});
    </code>
  </pre>

    <h3>2. task_manager.js - Task Management Component</h3>
    <p>
      Ab hum ek component banayenge jo TaskContext ko use karega. Is component mein hum tasks ko add, remove, aur update
      karenge.
    </p>
    <pre>
    <code class="language-javascript">
// static/src/task_manager.js
import { Component, useState, useEffect } from "owl";
import { TaskContext } from './context'; // Importing the global context

class TaskManager extends Component {
  // setup() hook mein state aur context ko initialize karte hain
  setup() {
    this.tasks = useState([]); // Local task list
    this.context = TaskContext; // Context ko use kar rahe hain
  }

  // mounted() hook mein hum initial task list fetch karte hain
  async mounted() {
    await this.fetchTasks();
  }

  // API se task list fetch karne ka method
  async fetchTasks() {
    const response = await fetch('/api/tasks');
    const data = await response.json();

    this.context.tasks = data; // Global context ko update karte hain
    this.tasks = data; // Local state ko update karte hain
  }

  // Method to add a new task
  async addTask(task) {
    const response = await fetch('/api/tasks', {
      method: 'POST',
      body: JSON.stringify({ task }),
    });
    const newTask = await response.json();

    this.context.tasks.push(newTask); // Global context ko update karte hain
    this.tasks.push(newTask); // Local state ko update karte hain
  }

  // Method to remove a task
  async removeTask(taskId) {
    await fetch(`/api/tasks/${taskId}`, { method: 'DELETE' });
    this.context.tasks = this.context.tasks.filter(task => task.id !== taskId); // Global context ko update karte hain
    this.tasks = this.tasks.filter(task => task.id !== taskId); // Local state ko update karte hain
  }

  // Method to render task list
  getTasks() {
    return this.context.tasks.map(task => `<li>${task.name}</li>`).join('');
  }
}

// Template ko associate karte hain
TaskManager.template = 'TaskManagerTemplate';
export default TaskManager;
    </code>
  </pre>

    <h3>3. templates.xml - Template File</h3>
    <p>
      Yeh XML file aapke UI ko define karegi. Yahaan hum Owl JS template system ka use karenge taaki humare component ka
      UI render ho sake.
    </p>
    <pre>
    <code class="language-xml">
&lt;!-- views/templates.xml --&gt;
&lt;odoo&gt;
  &lt;template id="TaskManagerTemplate"&gt;
    &lt;div&gt;
      &lt;h2&gt;Task Manager&lt;/h2&gt;
      &lt;ul t-esc="component.getTasks()" /&gt; &lt;!-- JavaScript method call karte hain --&gt;
      &lt;button t-on-click="component.addTask({ name: 'New Task' })"&gt;Add Task&lt;/button&gt;
    &lt;/div&gt;
  &lt;/template&gt;
&lt;/odoo&gt;
    </code>
  </pre>

    <h3>4. __manifest__.py - Module Manifest File</h3>
    <p>
      Manifest file mein hum Odoo ko batate hain ki is module ki dependencies kya hain, data files kaha hain (jaise
      templates.xml),
      aur JS assets kahan hain (jaise task_manager.js aur context.js).
    </p>
    <pre>
    <code class="language-python">
# __manifest__.py
{
  'name': 'Task Manager Module',
  'version': '1.0',
  'depends': ['web'], # Web module ki dependency
  'data': [
    'views/templates.xml', # Template file ko include karte hain
  ],
  'assets': {
    'web.assets_frontend': [
      'your_module/static/src/task_manager.js', # JS file ko link kar rahe hain
      'your_module/static/src/context.js', # Context file ko link kar rahe hain
    ],
  },
}
    </code>
  </pre>

    <h3>Code ki Explanation (Comments ke saath):</h3>
    <h4>Context (context.js):</h4>
    <p>
      context.js file mein humne TaskContext define kiya hai jo tasks ki list ko global state mein store karega.
      Hum useContext hook ka use kar rahe hain taaki is context ko apne components mein access kiya ja sake.
    </p>

    <h4>Component (task_manager.js):</h4>
    <p>
      <b>setup()</b>: Is hook ka use hum local state ko initialize karne ke liye karte hain. Hum context ko bhi yahan
      define karte hain taaki global state ko access kiya ja sake.<br>
      <b>mounted()</b>: Jab component mount hota hai, hum API se data fetch karte hain aur global context aur local
      state ko update karte hain.<br>
      <b>addTask()</b>: Yeh method ek new task ko add karne ke liye API call karta hai aur state aur context ko update
      karta hai.<br>
      <b>removeTask()</b>: Yeh method ek task ko remove karne ke liye API call karta hai aur state aur context ko update
      karta hai.<br>
      <b>getTasks()</b>: Yeh method task list ko render karne ke liye context se tasks ko fetch karta hai.
    </p>

    <h4>Template (templates.xml):</h4>
    <p>
      Template mein hum HTML structure ko define karte hain aur Owl JS ke t-esc aur t-on-click directives ka use karte
      hain taaki dynamic content display ho sake aur events handle kiye ja sake.
    </p>

    <h4>Manifest (__manifest__.py):</h4>
    <p>
      Manifest file mein hum Odoo ko batate hain ki kis module ki dependencies hain, data files kaha se fetch karne
      hain, aur JS assets kaha se load karne hain.
    </p>

    <h3>State Aur Effect Hooks ka Use:</h3>
    <p>
      <b>State Hook (useState)</b> ka use hum local component state ko manage karne ke liye karte hain. Jaise humne
      tasks ko store kiya hai.<br>
      <b>Effect Hook (useEffect)</b> ka use hum side-effects ko manage karne ke liye karte hain, jaise hum mounted()
      hook mein task list fetch kar rahe hain.
    </p>

    <h3>Lifecycle Hooks:</h3>
    <ul>
      <li><b>setup():</b> Is hook ka use hum component ke initialization ke liye karte hain, jahan hum state aur context
        ko initialize karte hain.</li>
      <li><b>mounted():</b> Ye hook tab trigger hota hai jab component DOM mein render hota hai. Hum is hook mein task
        list fetch karte hain taaki data ko fetch karke state ko update kiya ja sake.</li>
      <li><b>getTasks():</b> Yeh ek custom method hai jo UI ko render karte waqt context se tasks ko fetch karta hai.
      </li>
    </ul>

    <h3>Conclusion:</h3>
    <p>
      Is example mein:
    <ul>
      <li>Humne context ka use kiya hai taaki global state ko manage kiya ja sake.</li>
      <li>State aur Effect hooks ka istemal kiya gaya hai taaki data ko dynamically manage kiya ja sake aur component ki
        reactivity maintain ho sake.</li>
      <li>Lifecycle hooks ka use karke humne component ka behavior control kiya hai jaise task list fetch karna, state
        update karna, etc.</li>
    </ul>
    </p>
  </div>


  <!-- missisissssisisis -->

  <div class="content">
    <h1 class="section-title">Example 1: context.js - Global Task List Ko Manage Karna</h1>
    <pre class="highlight"><code class="language-javascript">
// static/src/context.js
import { useContext } from "owl";

// TaskContext ko define karte hain jo task list ko globally store karega
export const TaskContext = useContext({
  tasks: [],
});
    </code></pre>

    <h1 class="section-title">Example 2: task_manager.js - Component Mein State Aur Effect Hooks Ka Use</h1>
    <pre class="highlight"><code class="language-javascript">
// static/src/task_manager.js
import { Component, useState, useEffect } from "owl";
import { TaskContext } from './context'; // Importing global TaskContext

class TaskManager extends Component {
  // setup() hook mein state aur context ko initialize karte hain
  setup() {
    // Local state: New task ko store karne ke liye
    this.newTask = useState('');
    // Context: Task list ko globally store karne ke liye
    this.context = TaskContext;
  }

  // mounted() hook mein hum API se tasks ko fetch karte hain jab component mount hota hai
  async mounted() {
    await this.fetchTasks();
  }

  // API se tasks ko fetch karne ka method
  async fetchTasks() {
    const response = await fetch('/api/tasks');
    const data = await response.json();

    this.context.tasks = data; // Global context mein task list ko update karte hain
  }

  // Task ko add karne ka method
  addTask() {
    const task = this.newTask; // Local state se task ko get karte hain
    if (task) {
      this.context.tasks.push({ id: this.context.tasks.length + 1, name: task });
      this.newTask = ''; // Local state ko reset karte hain
    }
  }

  // Task ko remove karne ka method
  removeTask(id) {
    this.context.tasks = this.context.tasks.filter(task =&gt; task.id !== id);
  }

  // Method to render task list
  renderTaskList() {
    return this.context.tasks.map(task =&gt; {
      return `
      &lt;div class="task"&gt;
        &lt;span&gt;${task.name}&lt;/span&gt;
        &lt;button onclick="removeTask(${task.id})"&gt;Remove&lt;/button&gt;
      &lt;/div&gt;
      `;
    }).join('');
  }

  // Method to render the add task form
  renderAddTaskForm() {
    return `
    &lt;input type="text" value="${this.newTask}" onchange="this.newTask = event.target.value"
      placeholder="Add a new task" /&gt;
    &lt;button onclick="addTask()"&gt;Add Task&lt;/button&gt;
    `;
  }
}

// Template ko associate karte hain
TaskManager.template = 'TaskManagerTemplate';
export default TaskManager;
    </code></pre>

    <h1 class="section-title">Example 3: templates.xml - Template File Mein UI ko Define Karna</h1>
    <pre class="highlight"><code class="language-xml">
&lt;!-- views/templates.xml --&gt;
&lt;odoo&gt;
  &lt;template id="TaskManagerTemplate"&gt;
    &lt;div&gt;
      &lt;h2&gt;Task Manager&lt;/h2&gt;

      &lt;!-- Add Task Form --&gt;
      &lt;div t-raw="component.renderAddTaskForm()" /&gt;

      &lt;!-- Task List --&gt;
      &lt;div t-raw="component.renderTaskList()" /&gt;
    &lt;/div&gt;
  &lt;/template&gt;
&lt;/odoo&gt;
    </code></pre>
  </div>















  <div class="content">
    <h1 class="section-title">Example 1: context.js - Global Task List Ko Manage Karna</h1>
    <pre class="highlight"><code class="language-javascript">
// static/src/context.js
import { useContext } from "owl";

// TaskContext ko define karte hain jo task list ko globally store karega
export const TaskContext = useContext({
  tasks: [],
});
    </code></pre>

    <h1 class="section-title">Example 2: task_manager.js - Component Mein State Aur Effect Hooks Ka Use</h1>
    <pre class="highlight"><code class="language-javascript">
// static/src/task_manager.js
import { Component, useState, useEffect } from "owl";
import { TaskContext } from './context'; // Importing global TaskContext

class TaskManager extends Component {
  // setup() hook mein state aur context ko initialize karte hain
  setup() {
    // Local state: New task ko store karne ke liye
    this.newTask = useState('');
    // Context: Task list ko globally store karne ke liye
    this.context = TaskContext;
  }

  // mounted() hook mein hum API se tasks ko fetch karte hain jab component mount hota hai
  async mounted() {
    await this.fetchTasks();
  }

  // API se tasks ko fetch karne ka method
  async fetchTasks() {
    const response = await fetch('/api/tasks');
    const data = await response.json();

    this.context.tasks = data; // Global context mein task list ko update karte hain
  }

  // Task ko add karne ka method
  addTask() {
    const task = this.newTask; // Local state se task ko get karte hain
    if (task) {
      this.context.tasks.push({ id: this.context.tasks.length + 1, name: task });
      this.newTask = ''; // Local state ko reset karte hain
    }
  }

  // Task ko remove karne ka method
  removeTask(id) {
    this.context.tasks = this.context.tasks.filter(task =&gt; task.id !== id);
  }

  // Method to render task list
  renderTaskList() {
    return this.context.tasks.map(task =&gt; {
      return `
      &lt;div class="task"&gt;
        &lt;span&gt;${task.name}&lt;/span&gt;
        &lt;button onclick="removeTask(${task.id})"&gt;Remove&lt;/button&gt;
      &lt;/div&gt;
      `;
    }).join('');
  }

  // Method to render the add task form
  renderAddTaskForm() {
    return `
    &lt;input type="text" value="${this.newTask}" onchange="this.newTask = event.target.value"
      placeholder="Add a new task" /&gt;
    &lt;button onclick="addTask()"&gt;Add Task&lt;/button&gt;
    `;
  }
}

// Template ko associate karte hain
TaskManager.template = 'TaskManagerTemplate';
export default TaskManager;
    </code></pre>

    <h1 class="section-title">Example 3: templates.xml - Template File Mein UI ko Define Karna</h1>
    <pre class="highlight"><code class="language-xml">
&lt;!-- views/templates.xml --&gt;
&lt;odoo&gt;
  &lt;template id="TaskManagerTemplate"&gt;
    &lt;div&gt;
      &lt;h2&gt;Task Manager&lt;/h2&gt;

      &lt;!-- Add Task Form --&gt;
      &lt;div t-raw="component.renderAddTaskForm()" /&gt;

      &lt;!-- Task List --&gt;
      &lt;div t-raw="component.renderTaskList()" /&gt;
    &lt;/div&gt;
  &lt;/template&gt;
&lt;/odoo&gt;
    </code></pre>

    <h1 class="section-title">Example 4: __manifest__.py - Module Manifest File</h1>
    <pre class="highlight"><code class="language-python">
# __manifest__.py
{
  'name': 'Task Manager Module',
  'version': '1.0',
  'depends': ['web'],  # Web module ki dependency
  'data': [
    'views/templates.xml',  # Template file ko include kar rahe hain
  ],
  'assets': {
    'web.assets_frontend': [
      'your_module/static/src/task_manager.js',  # TaskManager component ko include kar rahe hain
      'your_module/static/src/context.js',  # TaskContext ko include kar rahe hain
    ],
  },
}
    </code></pre>

    <h2 class="section-title">Code Explanation (In Detail)</h2>
    <h3>Context (context.js):</h3>
    <p>
      TaskContext mein humne tasks ko store kiya hai jo global state ka part hai. Yeh tasks saare components mein
      accessible
      honge jo is context ko use karte hain.
    </p>

    <h3>Component (task_manager.js):</h3>
    <ul>
      <li><strong>setup()</strong>: Is hook ka use hum component ko initialize karte waqt karte hain. Hum yahan local
        state (newTask) aur global state (context.tasks) ko initialize karte hain.</li>
      <li><strong>mounted()</strong>: Jab component DOM mein mount hota hai, yeh hook trigger hota hai. Hum ismein API
        call karke tasks ko fetch karte hain aur global context ko update karte hain.</li>
      <li><strong>addTask()</strong>: Local state (newTask) ko use karke ek naya task add karte hain aur fir usse global
        context mein store karte hain.</li>
      <li><strong>removeTask()</strong>: Task ko global context se remove karne ka method hai.</li>
    </ul>

    <h3>Template (templates.xml):</h3>
    <p>
      Template mein hum tasks ko render karte hain jo context se fetch hoti hain. Hum input field aur buttons bhi render
      karte hain jo user interaction ko handle karte hain.
    </p>

    <h3>Manifest (__manifest__.py):</h3>
    <p>
      Is file mein hum module ki configuration karte hain, jaise data files aur assets ko link karna.
    </p>

    <h3>State Aur Effect Hooks ka Use:</h3>
    <ul>
      <li><strong>State Hook (useState):</strong> Humne newTask ko store karne ke liye local state ka use kiya hai. Jab
        user koi task add karta hai, toh yeh state update hoti hai.</li>
      <li><strong>Effect Hook (useEffect):</strong> Humne mounted() hook mein API se tasks fetch kiye hain aur global
        state ko update kiya hai. Yeh hook component mount hone par trigger hota hai.</li>
    </ul>

    <h3>Lifecycle Hooks:</h3>
    <ul>
      <li><strong>setup():</strong> Is hook mein humne local state aur global context ko initialize kiya.</li>
      <li><strong>mounted():</strong> Yeh hook component mount hone par trigger hota hai. Ismein hum API se data fetch
        karte hain aur context ko update karte hain.</li>
      <li><strong>addTask() aur removeTask():</strong> Yeh methods task ko add aur remove karte hain.</li>
    </ul>

    <h2 class="section-title">Conclusion:</h2>
    <p>
      Is example mein:
    </p>
    <ul>
      <li>Humne context ka use kiya hai taaki task list ko globally manage kiya ja sake.</li>
      <li>State aur Effect hooks ka use karke humne component ko reactive aur dynamic banaya hai.</li>
      <li>Lifecycle hooks ka use karke humne component ke behavior ko efficiently control kiya hai, jaise data fetch
        karna aur update karna.</li>
    </ul>
  </div>




  <div class="content">
    <h1 class="section-title">Example 1: context.js - Global Task List Ko Manage Karna</h1>
    <pre class="highlight"><code class="language-javascript">
// static/src/context.js
import { useContext } from "owl";

// TaskContext ko define karte hain jo task list ko globally store karega
export const TaskContext = useContext({
  tasks: [],
});
    </code></pre>

    <h1 class="section-title">Example 2: task_manager.js - Component Mein State Aur Effect Hooks Ka Use</h1>
    <pre class="highlight"><code class="language-javascript">
// static/src/task_manager.js
import { Component, useState, useEffect } from "owl";
import { TaskContext } from './context'; // Importing global TaskContext

class TaskManager extends Component {
  // setup() hook mein state aur context ko initialize karte hain
  setup() {
    // Local state: New task ko store karne ke liye
    this.newTask = useState('');
    // Context: Task list ko globally store karne ke liye
    this.context = TaskContext;
  }

  // mounted() hook mein hum API se tasks ko fetch karte hain jab component mount hota hai
  async mounted() {
    await this.fetchTasks();
  }

  // API se tasks ko fetch karne ka method
  async fetchTasks() {
    const response = await fetch('/api/tasks');
    const data = await response.json();

    this.context.tasks = data; // Global context mein task list ko update karte hain
  }

  // Task ko add karne ka method
  addTask() {
    const task = this.newTask; // Local state se task ko get karte hain
    if (task) {
      this.context.tasks.push({ id: this.context.tasks.length + 1, name: task });
      this.newTask = ''; // Local state ko reset karte hain
    }
  }

  // Task ko remove karne ka method
  removeTask(id) {
    this.context.tasks = this.context.tasks.filter(task =&gt; task.id !== id);
  }

  // Method to render task list
  renderTaskList() {
    return this.context.tasks.map(task =&gt; {
      return `
      &lt;div class="task"&gt;
        &lt;span&gt;${task.name}&lt;/span&gt;
        &lt;button onclick="removeTask(${task.id})"&gt;Remove&lt;/button&gt;
      &lt;/div&gt;
      `;
    }).join('');
  }

  // Method to render the add task form
  renderAddTaskForm() {
    return `
    &lt;input type="text" value="${this.newTask}" onchange="this.newTask = event.target.value"
      placeholder="Add a new task" /&gt;
    &lt;button onclick="addTask()"&gt;Add Task&lt;/button&gt;
    `;
  }
}

// Template ko associate karte hain
TaskManager.template = 'TaskManagerTemplate';
export default TaskManager;
    </code></pre>

    <h1 class="section-title">Example 3: templates.xml - Template File Mein UI ko Define Karna</h1>
    <pre class="highlight"><code class="language-xml">
&lt;!-- views/templates.xml --&gt;
&lt;odoo&gt;
  &lt;template id="TaskManagerTemplate"&gt;
    &lt;div&gt;
      &lt;h2&gt;Task Manager&lt;/h2&gt;

      &lt;!-- Add Task Form --&gt;
      &lt;div t-raw="component.renderAddTaskForm()" /&gt;

      &lt;!-- Task List --&gt;
      &lt;div t-raw="component.renderTaskList()" /&gt;
    &lt;/div&gt;
  &lt;/template&gt;
&lt;/odoo&gt;
    </code></pre>

    <h1 class="section-title">Example 4: __manifest__.py - Module Manifest File</h1>
    <pre class="highlight"><code class="language-python">
# __manifest__.py
{
  'name': 'Task Manager Module',
  'version': '1.0',
  'depends': ['web'],  # Web module ki dependency
  'data': [
    'views/templates.xml',  # Template file ko include kar rahe hain
  ],
  'assets': {
    'web.assets_frontend': [
      'your_module/static/src/task_manager.js',  # TaskManager component ko include kar rahe hain
      'your_module/static/src/context.js',  # TaskContext ko include kar rahe hain
    ],
  },
}
    </code></pre>

    <h1 class="section-title">Data Fetching (mounted() Method and fetchTasks())</h1>
    <h3>mounted()</h3>
    <p>
      Jab component DOM pe first time render hota hai, toh <code>mounted()</code> method automatically call hota hai.
      Yeh <code>useEffect</code> ki tarah kaam karta hai jo aapko lifecycle ke start mein action perform karne ki
      suvidha
      deta hai. Hum yahan <code>fetchTasks()</code> function call kar rahe hain, jo API se data fetch karta hai.
    </p>

    <h3>fetchTasks()</h3>
    <p>
      Yeh method API call ko handle karta hai. API se data ko fetch karne ke liye hum <code>fetch()</code> method ka use
      karte hain.
      Yeh asynchronous operation hai, isliye hum <code>await</code> ka use karte hain taaki code sequentially execute ho
      aur data milne ke baad next step ho. Agar data fetch ho jata hai, toh <code>this.tasks</code> ko update kar dete
      hain.
      Agar kuch galat hota hai toh error catch hota hai aur console pe print hota hai. Finally,
      <code>this.loading = false</code>
      karke loading ko disable kar dete hain jab data fetch ho jata hai.
    </p>

    <h1 class="section-title">UI Rendering (Displaying Data)</h1>
    <p>
      <code>render()</code> method mein hum loading aur tasks state ko check karte hain. Agar loading state true hai,
      toh "Loading..." message display hota hai. Agar loading state false hai (data successfully load ho gaya hai),
      toh tasks ko ek list ke form mein display kiya jata hai using <code>t-foreach</code>.
    </p>

    <h1 class="section-title">Owl Template</h1>
    <p>
      Template mein hum <code>t-if</code> directive ka use karte hain jo conditional rendering ko handle karta hai.
      Agar loading state true hai, toh "Loading..." message dikhata hai, aur jab data load ho jata hai toh task list ko
      render karte hain.
    </p>

    <h1 class="section-title">Odoo Module Integration</h1>
    <h3>Module Manifest (__manifest__.py)</h3>
    <pre class="highlight"><code class="language-python">
# __manifest__.py
{
  'name': 'Task Fetcher Module',
  'version': '1.0',
  'depends': ['web'],  # Web module ko depend kar rahe hain
  'data': [
    'views/templates.xml',  # Template file ko include kar rahe hain
  ],
  'assets': {
    'web.assets_frontend': [
      'your_module/static/src/task_fetcher.js',  # TaskFetcher component ko include kar rahe hain
    ],
  },
}
    </code></pre>

    <h3>Template File (templates.xml)</h3>
    <pre class="highlight"><code class="language-xml">
&lt;odoo&gt;
  &lt;template id="TaskFetcherTemplate"&gt;
    &lt;div&gt;
      &lt;h2&gt;Task List&lt;/h2&gt;
      &lt;!-- Loading state ko show karte hain --&gt;
      &lt;div t-if="component.loading"&gt;Loading...&lt;/div&gt;

      &lt;!-- Jab data load ho jata hai toh tasks ko display karte hain --&gt;
      &lt;div t-if="!component.loading"&gt;
        &lt;ul&gt;
          &lt;li t-foreach="component.tasks" t-as="task"&gt;
            &lt;span&gt;
              &lt;t t-esc="task.title" /&gt;
            &lt;/span&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/template&gt;
&lt;/odoo&gt;
    </code></pre>

    <h1 class="section-title">Conclusion (In-depth Explanation)</h1>
    <p>
      <code>useState</code> aur <code>useEffect</code> hooks ko use kar ke hum apne component ka state manage kar rahe
      hain aur
      asynchronous side-effects (jaise API calls) ko efficiently handle kar rahe hain. <code>useState</code> hook se hum
      task list
      aur loading states ko manage karte hain, jisse UI reactively update hota hai jab bhi state change hota hai.
    </p>
    <p>
      <code>mounted()</code> hook, jo <code>useEffect</code> ki tarah kaam karta hai, component ke mount hone ke baad
      API call
      karta hai aur fetched data ko state mein update karta hai.
    </p>
  </div>



  <div class="content">
    <h1 class="section-title">OWL Mein Routing Aur Navigation: Detailed Explanation</h1>
    <p>
      OWL (Odoo Web Library) ek powerful JavaScript framework hai jo Odoo mein dynamic aur interactive UIs banane ke
      liye use hota hai. Jab hum routing aur navigation ki baat karte hain, toh iska matlab hota hai ki hum apne
      application ke different views ya pages ke beech move kar sakein, jo ek structured way mein render hote hain, aur
      URLs ko dynamically manage kiya ja sake.
    </p>
    <p>
      Is detailed explanation mein, hum OWL mein Routing aur Navigation ke concepts ko samjhenge, aur kaise hum inhe
      Odoo mein implement kar sakte hain. Hum is example mein HomePage aur DetailsPage components banayenge, jo
      route-based navigation implement karenge. Yeh example aapke Odoo custom UI mein use kiya ja sakta hai.
    </p>

    <h1 class="section-title">OWL Routing Concepts</h1>
    <p>
      OWL mein routing ka concept kuch is tarah kaam karta hai:
    <ul>
      <li><strong>Routing:</strong> Routing ka matlab hota hai kisi specific URL ke basis par kisi component ko render
        karna.</li>
      <li><strong>Dynamic Routes:</strong> Yeh wo routes hote hain jisme parameters included hote hain. Jaise agar hum
        <code>/details/:id</code> route ka use karte hain, toh <code>:id</code> ek placeholder hota hai jisme hum
        dynamically kisi specific ID ko pass karte hain.
      </li>
      <li><strong>Navigation:</strong> Navigation ka matlab hai ek page se doosre page par jaana.</li>
    </ul>
    </p>

    <h1 class="section-title">Step 1: Components Banayein</h1>
    <h3>HomePage Component (HomePage.js)</h3>
    <p>
      Yeh component ek simple welcome message show karega aur ek button hoga jisse hum DetailsPage par navigate kar
      sakte hain.
    </p>
    <pre class="highlight"><code class="language-javascript">
// static/src/home_page.js
import { Component } from "owl"; // OWL Component ko import kar rahe hain

class HomePage extends Component {
  setup() {
    this.message = "Home Page par aapka swagat hai!"; // Home page ka welcome message
  }

  render() {
    return `
    <div>
      <h2>
        <t t-esc="message" />
      </h2> <!-- Message display karte hain -->
      <button t-on-click="navigateToDetails">Go to Details</button> <!-- Button to navigate to Details page -->
    </div>
    `;
  }

  // navigateToDetails method - jab button pe click hoga toh Details page par navigate karenge
  navigateToDetails() {
    this.props.router.navigate("/details/1"); // Navigate karte hain Details page par, ID = 1
  }
}

export default HomePage;
    </code></pre>
    <p>
      <strong>Explanation:</strong>
    <ul>
      <li><code>setup()</code> method mein hum component ke initial state ko define karte hain, jaise
        <code>this.message</code> ko "Home Page par aapka swagat hai!" set kiya hai.
      </li>
      <li><code>render()</code> method mein hum template return karte hain, jisme ek button hai. Jab user is button ko
        click karega, toh <code>navigateToDetails()</code> method call hoga.</li>
      <li><code>navigateToDetails()</code> method mein <code>this.props.router.navigate("/details/1")</code> use kiya
        gaya hai, jo DetailsPage par navigate karne ka kaam karega.</li>
    </ul>
    </p>

    <h3>DetailsPage Component (DetailsPage.js)</h3>
    <p>
      Yeh component dynamically route ke parameter (id) ko access karta hai aur details display karta hai.
    </p>
    <pre class="highlight"><code class="language-javascript">
// static/src/details_page.js
import { Component } from "owl"; // OWL Component ko import kar rahe hain

class DetailsPage extends Component {
  setup() {
    this.routeParams = this.props.router.params; // URL se route params ko fetch kar rahe hain
    this.message = `Details for ID: ${this.routeParams.id}`; // ID ke basis par message display karte hain
  }

  render() {
    return `
    <div>
      <h2>
        <t t-esc="message" />
      </h2> <!-- Dynamic message display karte hain -->
      <button t-on-click="navigateToHome">Go to Home</button> <!-- Button to navigate to Home -->
    </div>
    `;
  }

  // navigateToHome method - jab button pe click hoga toh Home page par navigate karenge
  navigateToHome() {
    this.props.router.navigate("/home"); // Home page par navigate karenge
  }
}

export default DetailsPage;
    </code></pre>
    <p>
      <strong>Explanation:</strong>
    <ul>
      <li><code>setup()</code> method mein <code>this.props.router.params</code> se hum URL parameters ko access karte
        hain. Jaise agar URL <code>/details/1</code> hai, toh <code>this.routeParams.id</code> ko 1 milega.</li>
      <li><code>render()</code> method mein dynamic message ko display karte hain jo URL parameter (id) ke basis par
        change hota hai.</li>
      <li><code>navigateToHome()</code> method mein hum <code>this.props.router.navigate("/home")</code> use karte hain
        jo HomePage par navigate karne ka kaam karega.</li>
    </ul>
    </p>

    <h1 class="section-title">Step 2: Routing Setup</h1>
    <p>
      Ab hum routes ko define karenge aur unhe components ke saath link karenge. Routes ko define karte waqt hum dynamic
      parameters ko bhi consider karenge.
    </p>
    <pre class="highlight"><code class="language-javascript">
// static/src/router.js
import { Router, Route } from "owl.router"; // OWL se Router aur Route ko import kar rahe hain
import HomePage from "./home_page"; // HomePage ko import kar rahe hain
import DetailsPage from "./details_page"; // DetailsPage ko import kar rahe hain

// Define kar rahe hain routes ko
const routes = [
  {
    path: "/home", // Static path for Home
    component: HomePage, // HomePage component ko link kar rahe hain
  },
  {
    path: "/details/:id", // Dynamic path for Details (id ke sath)
    component: DetailsPage, // DetailsPage component ko link kar rahe hain
  }
];

// MyApp component return kar rahe hain jo Router ko wrap karega
export const MyApp = () => {
  return (
    <Router routes={routes}> {/* Router component ko routes ke saath wrap kar rahe hain */}
      {/* Routes ke according components render honge */}
    </Router>
  );
};
    </code></pre>
    <p>
      <strong>Explanation:</strong>
    <ul>
      <li><code>routes</code> array mein hum define kar rahe hain ki kaunse URL par kaunsa component render hoga:
        <ul>
          <li><code>/home</code> route par HomePage render hoga.</li>
          <li><code>/details/:id</code> route par DetailsPage render hoga, jahan <code>:id</code> dynamic parameter hai.
          </li>
        </ul>
      </li>
      <li><code>Router</code> component ko use karke hum routes ko manage karte hain aur components ko render karte
        hain.</li>
    </ul>
    </p>

  </div>



  <div class="content">
    <h1 class="section-title">Step 3: Mounting OWL App</h1>
    <p>Ab hum MyApp component ko DOM mein mount karenge, jisse hum apne app ko render kar sakein.</p>

    <h2 class="subsection-title">Main Application Mounting (main.js)</h2>
    <pre class="highlight"><code class="language-javascript">&lt;!-- static/src/main.js --&gt;
import { mount } from 'owl'; // OWL se mount ko import kar rahe hain
import { MyApp } from './router'; // MyApp ko import kar rahe hain (jo routing ko handle karta hai)

// Mounting the OWL app to the DOM
const app = new MyApp(); // MyApp component ka ek instance create kar rahe hain
mount(app, document.body); // App ko body mein mount kar rahe hain
  </code></pre>
    <p>Explanation:</p>
    <p>mount() function se hum MyApp component ko DOM mein render karte hain. Yeh app apne routes ke through decide
      karega ki kaunsa component render karna hai.</p>
    <p>Isse hum apne application ko start karte hain aur UI ko dynamically update karte hain based on routes.</p>

    <h2 class="subsection-title">Real World Example in Odoo Context</h2>
    <p>Is routing aur navigation setup ka use Odoo mein bhi kiya ja sakta hai. Maan lijiye ki aap ek Odoo module bana
      rahe hain jisme aapko Product Management aur Product Details ka page setup karna hai. Aap home page par list of
      products dikha sakte hain, aur jab user kisi product par click karega, toh uske details ek nayi page par open
      honge. Yeh implementation OWL mein aapke custom Odoo modules ke liye kaafi useful hoga.</p>

    <h1 class="section-title">project</h1>
    <p>Building a comprehensive Odoo project that uses all of the mentioned features (Backend models, Frontend views,
      API integration, Routing, Token-based Authentication, etc.) is a multi-faceted task. Below is an example of a
      complete project that combines all these concepts to build a "Task Management System" module in Odoo. This example
      will cover:</p>

    <ul>
      <li>Backend Models: Task management with a priority system.</li>
      <li>Frontend Views: Create dynamic pages to manage tasks.</li>
      <li>API Integration: Allow interaction via RESTful APIs.</li>
      <li>Routing: Use dynamic routing to access different task-related pages.</li>
      <li>Token Authentication: Secure API access using tokens.</li>
    </ul>

    <h2 class="subsection-title">Module Structure</h2>
    <pre class="highlight"><code class="language-css">task_management/
├── controllers/
│   └── main.py
├── models/
│   └── task.py
├── views/
│   ├── task_form_view.xml
│   ├── task_tree_view.xml
│   ├── assets.xml
│   └── templates.xml
├── security/
│   └── ir.model.access.csv
├── static/
│   └── src/
│       └── js/
│           └── task_management.js
├── __init__.py
├── __manifest__.py
└── routes.py
  </code></pre>

    <h2 class="subsection-title">1. Manifest File (__manifest__.py)</h2>
    <pre class="highlight"><code class="language-python">&lt;!-- __manifest__.py --&gt;
{
  'name': 'Task Management System',
  'version': '1.0',
  'category': 'Project',
  'summary': 'Manage tasks with dynamic views, token-based API, and routing.',
  'author': 'Your Name',
  'website': 'https://www.yourwebsite.com',
  'depends': ['base', 'web'],
  'data': [
    'security/ir.model.access.csv',
    'views/task_form_view.xml',
    'views/task_tree_view.xml',
    'views/templates.xml',
    'views/assets.xml',
  ],
  'assets': {
    'web.assets_backend': [
      'task_management/static/src/js/task_management.js',
    ],
  },
  'controllers': [
    'controllers/main.py',
  ],
  'installable': True,
  'application': True,
}
  </code></pre>

    <h2 class="subsection-title">2. Backend Model (models/task.py)</h2>
    <pre class="highlight"><code class="language-python">&lt;!-- models/task.py --&gt;
from odoo import models, fields, api
import uuid

class Task(models.Model):
  _name = 'task.management'
  _description = 'Task Management'

  name = fields.Char(string='Task Name', required=True)
  description = fields.Text(string='Task Description')
  priority = fields.Selection([
    ('low', 'Low'),
    ('medium', 'Medium'),
    ('high', 'High')
  ], string='Priority', default='medium')
  assigned_to = fields.Many2one('res.users', string='Assigned to')
  deadline = fields.Datetime(string='Deadline')
  state = fields.Selection([
    ('new', 'New'),
    ('in_progress', 'In Progress'),
    ('completed', 'Completed'),
  ], string='State', default='new')

  # API Token (for authentication)
  token = fields.Char(string='Token', readonly=True)

  @api.model
  def create(self, values):
    # Generate token when a new task is created
    values['token'] = self._generate_token()
    return super(Task, self).create(values)

  def _generate_token(self):
    # Generate a unique token for each task
    return str(uuid.uuid4())
  </code></pre>

    <h2 class="subsection-title">3. Security Rules (security/ir.model.access.csv)</h2>
    <pre class="highlight"><code class="language-csv">&lt;!-- security/ir.model.access.csv --&gt;
access_task_management_user,access.task.management.user,model_task_management,base.group_user,1,1,1,1
  </code></pre>

    <h2 class="subsection-title">4. Views for Backend (views/task_form_view.xml)</h2>
    <pre class="highlight"><code class="language-xml">&lt;!-- views/task_form_view.xml --&gt;
&lt;odoo&gt;
  &lt;record id="view_form_task_management" model="ir.ui.view"&gt;
    &lt;field name="name"&gt;task.management.form&lt;/field&gt;
    &lt;field name="model"&gt;task.management&lt;/field&gt;
    &lt;field name="arch" type="xml"&gt;
      &lt;form string="Task"&gt;
        &lt;group&gt;
          &lt;field name="name" /&gt;
          &lt;field name="description" /&gt;
          &lt;field name="priority" /&gt;
          &lt;field name="assigned_to" /&gt;
          &lt;field name="deadline" /&gt;
          &lt;field name="state" /&gt;
          &lt;field name="token" readonly="1" /&gt;
        &lt;/group&gt;
      &lt;/form&gt;
    &lt;/field&gt;
  &lt;/record&gt;
&lt;/odoo&gt;
  </code></pre>

    <h2 class="subsection-title">5. Views for Tree/List (views/task_tree_view.xml)</h2>
    <pre class="highlight"><code class="language-xml">&lt;!-- views/task_tree_view.xml --&gt;
&lt;odoo&gt;
  &lt;record id="view_tree_task_management" model="ir.ui.view"&gt;
    &lt;field name="name"&gt;task.management.tree&lt;/field&gt;
    &lt;field name="model"&gt;task.management&lt;/field&gt;
    &lt;field name="arch" type="xml"&gt;
      &lt;tree&gt;
        &lt;field name="name" /&gt;
        &lt;field name="priority" /&gt;
        &lt;field name="assigned_to" /&gt;
        &lt;field name="state" /&gt;
      &lt;/tree&gt;
    &lt;/field&gt;
  &lt;/record&gt;
&lt;/odoo&gt;
  </code></pre>
  </div>

  <div class="content">
    <h1 class="section-title">6. API Routes and Controllers (controllers/main.py)</h1>

    <pre class="highlight"><code class="language-python">&lt;!-- controllers/main.py --&gt;
  from odoo import http
  from odoo.http import request
  import json
  
  class TaskManagementController(http.Controller):
  
    @http.route('/task/api/tasks', type='json', auth='public', methods=['GET'], csrf=False)
    def get_tasks(self, **kwargs):
      # Fetch all tasks from the model and return as JSON
      tasks = request.env['task.management'].search([])
      tasks_data = []
      for task in tasks:
        tasks_data.append({
          'id': task.id,
          'name': task.name,
          'priority': task.priority,
          'assigned_to': task.assigned_to.name,
          'state': task.state,
          'token': task.token
        })
      return json.dumps(tasks_data)
  
    @http.route('/task/api/task/&lt;int:id&gt;', type='json', auth='public', methods=['GET'], csrf=False)
    def get_task(self, id, **kwargs):
      # Fetch a specific task by ID
      task = request.env['task.management'].browse(id)
      if task:
        return json.dumps({
          'id': task.id,
          'name': task.name,
          'priority': task.priority,
          'assigned_to': task.assigned_to.name,
          'state': task.state,
          'token': task.token
        })
      return json.dumps({"error": "Task not found"})
  
    @http.route('/task/api/create', type='json', auth='user', methods=['POST'], csrf=False)
    def create_task(self, **kwargs):
      # Create a new task and return a response
      task = request.env['task.management'].create({
        'name': kwargs.get('name'),
        'description': kwargs.get('description'),
        'priority': kwargs.get('priority'),
        'assigned_to': kwargs.get('assigned_to'),
        'deadline': kwargs.get('deadline'),
      })
      return json.dumps({'message': 'Task created successfully', 'task_id': task.id})
    </code></pre>

    <h2 class="subsection-title">7. Frontend Assets (views/assets.xml)</h2>
    <pre class="highlight"><code class="language-xml">&lt;!-- views/assets.xml --&gt;
  &lt;odoo&gt;
    &lt;template id="assets_backend" name="task_management_assets" inherit_id="web.assets_backend"&gt;
      &lt;xpath expr="." position="inside"&gt;
        &lt;script type="text/javascript" src="/task_management/static/src/js/task_management.js"&gt;&lt;/script&gt;
      &lt;/xpath&gt;
    &lt;/template&gt;
  &lt;/odoo&gt;
    </code></pre>

    <h2 class="subsection-title">8. Frontend Template (views/templates.xml)</h2>
    <pre class="highlight"><code class="language-xml">&lt;!-- views/templates.xml --&gt;
  &lt;odoo&gt;
    &lt;template id="task_list_page" name="Task List Page"&gt;
      &lt;t t-foreach="tasks" t-as="task"&gt;
        &lt;div class="task-card"&gt;
          &lt;h3&gt;
            &lt;t t-esc="task.name" /&gt;
          &lt;/h3&gt;
          &lt;p&gt;
            &lt;t t-esc="task.priority" /&gt; - &lt;t t-esc="task.state" /&gt;
          &lt;/p&gt;
          &lt;p&gt;
            &lt;t t-esc="task.assigned_to" /&gt;
          &lt;/p&gt;
          &lt;button t-on-click="viewDetails(task.id)"&gt;View Details&lt;/button&gt;
        &lt;/div&gt;
      &lt;/t&gt;
    &lt;/template&gt;
  &lt;/odoo&gt;
    </code></pre>

    <h2 class="subsection-title">9. Frontend JavaScript (static/src/js/task_management.js)</h2>
    <pre class="highlight"><code class="language-javascript">// static/src/js/task_management.js
  odoo.define('task_management.task_management', function (require) {
  "use strict";
  
  var rpc = require('web.rpc');
  var core = require('web.core');
  var Widget = require('web.Widget');
  
  var TaskListPage = Widget.extend({
    template: 'task_list_page',
  
    start: function () {
      this._super.apply(this, arguments);
      this.loadTasks();
    },
  
    loadTasks: function () {
      var self = this;
      rpc.query({
        route: '/task/api/tasks',
      }).then(function (result) {
        self.tasks = result;
        self.render();
      });
    },
  
    viewDetails: function (taskId) {
      window.location.href = `/task/${taskId}`;
    },
  });
  
  core.action_registry.add('task_list_page', TaskListPage);
  });
    </code></pre>

    <h2 class="subsection-title">10. Routing for Frontend</h2>
    <p>In Odoo, frontend routing is typically done through core and actions. You can use a custom view or extend the
      current routing mechanism to create a dynamic page. The JavaScript file above handles the fetching of task data
      dynamically using rpc.</p>
  </div>


  <div class="content">
    <h1 class="section-title">11. Testing and Final Setup</h1>

    <p>After you have completed all the components, you should follow these steps to ensure everything is working as
      expected.</p>

    <h2 class="subsection-title">Step 1: Installing the Module</h2>
    <ul>
      <li>Install the module in your Odoo instance.</li>
      <li>Go to Apps, and click Update Apps List to ensure the new module is visible.</li>
      <li>Search for the module name "Task Management System" and click Install.</li>
    </ul>

    <h2 class="subsection-title">Step 2: Testing the Backend</h2>
    <p>Create a task:</p>
    <ul>
      <li>Go to the Task Management menu in Odoo and create a new task through the form view.</li>
      <li>Test if the Token is generated properly when creating a task.</li>
    </ul>

    <p>Access the task list:</p>
    <ul>
      <li>In the Task Management menu, test the tree view to check if all the tasks are listed correctly, including
        their attributes such as priority, assigned_to, and state.</li>
    </ul>

    <h2 class="subsection-title">Step 3: Testing the API (Token-Based Authentication)</h2>

    <p>Fetch all tasks:</p>
    <pre class="highlight"><code class="language-bash">curl -X GET http://your-odoo-instance/task/api/tasks</code></pre>
    <p>This should return a list of all tasks in JSON format.</p>

    <p>Fetch a specific task:</p>
    <pre
      class="highlight"><code class="language-bash">curl -X GET http://your-odoo-instance/task/api/task/1</code></pre>

    <p>Create a new task:</p>
    <pre class="highlight"><code class="language-bash">curl -X POST http://your-odoo-instance/task/api/create \
    -d "name=New Task&priority=high&assigned_to=2&deadline=2024-11-30"</code></pre>
    <p>Ensure the new task is created and you receive a success message with the task ID.</p>

    <h2 class="subsection-title">Step 4: Testing Frontend (Dynamic Routing and Interaction)</h2>

    <p>Task List Page:</p>
    <ul>
      <li>Go to the Task List Page on the Odoo frontend. You should see a list of tasks that you fetched using the RPC
        method.</li>
      <li>The "View Details" button should dynamically route you to the Task Detail page for the specific task (using a
        dynamic route in the frontend).</li>
    </ul>

    <p>Task Details Page:</p>
    <ul>
      <li>If you click the View Details button for any task, you should be redirected to a detailed page of the task
        (ensure you create a new route for this detail page, if not already done).</li>
    </ul>

    <h2 class="subsection-title">Step 5: Handling Authentication (Token Validation)</h2>

    <p>Secure API Routes:</p>
    <p>For authenticated routes (like task creation), you need to validate the token before processing the request.</p>

    <p>Example of token validation in the controller:</p>

    <pre class="highlight"><code class="language-python">&lt;!-- controllers/main.py --&gt;
  from odoo import http
  from odoo.http import request
  import json
  
  class TaskManagementController(http.Controller):
  
    @http.route('/task/api/create', type='json', auth='user', methods=['POST'], csrf=False)
    def create_task(self, **kwargs):
      # Get the token from the request
      token = kwargs.get('token')
      task_model = request.env['task.management']
  
      # Check if the token matches
      if not task_model.search([('token', '=', token)]):
        return json.dumps({"error": "Invalid token"})
  
      # Create task only if token is valid
      task = task_model.create({
        'name': kwargs.get('name'),
        'description': kwargs.get('description'),
        'priority': kwargs.get('priority'),
        'assigned_to': kwargs.get('assigned_to'),
        'deadline': kwargs.get('deadline'),
      })
  
      return json.dumps({'message': 'Task created successfully', 'task_id': task.id})
    </code></pre>

    <p>This ensures that only requests with a valid token can create new tasks, providing basic security for the API.
    </p>

    <h2 class="subsection-title">Step 6: Customizing and Extending the Functionality</h2>

    <p>You can add additional features based on your needs:</p>
    <ul>
      <li><strong>Search and Filter:</strong> You can implement search and filter capabilities on both the frontend and
        backend to make it easier to find tasks based on certain criteria like priority, state, etc.</li>
      <li><strong>Task States:</strong> Add features like allowing the task state to change via the frontend, or through
        an API endpoint, so tasks can move from "new" to "in_progress" to "completed".</li>
      <li><strong>User Permissions:</strong> You can restrict certain actions (like task creation or task editing) based
        on user roles. Modify the security rules to implement these restrictions.</li>
    </ul>

    <h2 class="subsection-title">Complete Example Recap:</h2>
    <p>In this example, you built a Task Management System with Odoo that:</p>
    <ul>
      <li><strong>Backend Model:</strong> Defined a task.management model with attributes like name, description,
        priority, assigned_to, etc.</li>
      <li><strong>Frontend Views:</strong> Created views for displaying tasks and a form for task creation.</li>
      <li><strong>API Integration:</strong> Exposed a REST API to manage tasks (CRUD operations).</li>
      <li><strong>Routing:</strong> Implemented dynamic routing to access different task views.</li>
      <li><strong>Token-Based Authentication:</strong> Secured the API routes by validating the task token before
        processing requests.</li>
      <li><strong>Frontend Interaction:</strong> Used JavaScript to fetch and display tasks dynamically and to create
        new tasks via the API.</li>
    </ul>

    <h2 class="subsection-title">Conclusion:</h2>
    <p>This project showcases how to create a full-featured Odoo module that leverages Odoo's backend for business
      logic, frontend for user interaction, API integration for external access, routing for navigation, and token-based
      authentication for securing sensitive operations. Each piece of functionality is interconnected, creating a
      seamless experience within the Odoo ecosystem.</p>

    <p>By breaking down this project, you can easily extend and scale it by adding more features, improving the UI, or
      integrating with other Odoo modules.</p>
  </div>







  <div class="content">
    <h1 class="section-title">task_management/</h1>
    <ul>
      <li>controllers/
        <ul>
          <li><span class="important">main.py</span></li>
        </ul>
      </li>
      <li>models/
        <ul>
          <li><span class="important">task.py</span></li>
        </ul>
      </li>
      <li>views/
        <ul>
          <li><span class="important">task_form_view.xml</span></li>
          <li><span class="important">task_tree_view.xml</span></li>
          <li><span class="important">assets.xml</span></li>
          <li><span class="important">templates.xml</span></li>
        </ul>
      </li>
      <li>security/
        <ul>
          <li><span class="important">ir.model.access.csv</span></li>
        </ul>
      </li>
      <li>static/
        <ul>
          <li>src/
            <ul>
              <li>js/
                <ul>
                  <li><span class="important">task_management.js</span></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li><span class="important">__init__.py</span></li>
      <li><span class="important">__manifest__.py</span></li>
      <li><span class="important">routes.py</span></li>
    </ul>
  </div>

  <div class="content">
    <h2 class="subsection-title">ChatGPT said:</h2>
    <p>Sure! Let's go through the file structure of the task_management module and explain each file in detail, using
      comments in your language to make it easy to understand.</p>

    <h3 class="subsection-title">1. controllers/main.py</h3>
    <p>This file is where we define the logic to handle HTTP requests. It contains routes (URLs) that handle the logic
      for creating, updating, or retrieving tasks. This is the backend controller that processes the user’s actions
      and responses.</p>

    <pre><code class="language-python">
  # main.py
  
  from odoo import http
  from odoo.http import request
  
  class TaskManagementController(http.Controller):
      # Yeh route task create karne ke liye hai
      @http.route('/task/api/create', type='json', auth='user', methods=['POST'], csrf=False)
      def create_task(self, **kwargs):
          # Token ko request se le rahe hain (for authentication)
          token = kwargs.get('token')
          task_model = request.env['task.management'] # Task model ko fetch kar rahe hain
  
          # Agar token invalid hai toh error return karenge
          if not task_model.search([('token', '=', token)]):
              return {"error": "Invalid token"}
  
          # Token valid hai toh task create karenge
          task = task_model.create({
              'name': kwargs.get('name'),
              'description': kwargs.get('description'),
              'priority': kwargs.get('priority'),
              'assigned_to': kwargs.get('assigned_to'),
              'deadline': kwargs.get('deadline'),
          })
  
          # Task create hone par success message
          return {"message": "Task created successfully", "task_id": task.id}
      </code></pre>

    <p><strong>Explanation:</strong></p>
    <p>create_task: Yeh function task create karne ka kaam karta hai. @http.route decorator se hum POST method ke liye
      ek route define karte hain jo /task/api/create par available hoga. Ismein token-based authentication hota hai,
      jisme token verify karte hain. Agar token valid hai toh task create karte hain aur success message bhejte hain.
    </p>

    <h3 class="subsection-title">2. models/task.py</h3>
    <p>Yeh file backend model ko define karti hai jo tasks ki data ko store karta hai. Ye data Odoo ke database mein
      store hota hai.</p>

    <pre><code class="language-python">
  # task.py
  
  from odoo import models, fields
  
  class TaskManagement(models.Model):
      _name = 'task.management' # Model ka name define karte hain
      _description = 'Task Management'
  
      name = fields.Char('Task Name', required=True)
      description = fields.Text('Description')
      priority = fields.Selection([('low', 'Low'), ('medium', 'Medium'), ('high', 'High')], 'Priority', default='medium')
      assigned_to = fields.Many2one('res.users', string='Assigned to') # Res.users model ke sath relationship
      deadline = fields.Datetime('Deadline')
      token = fields.Char('Task Token', required=True) # Task token for authentication
      </code></pre>

    <p><strong>Explanation:</strong></p>
    <p>Humne ek task.management model banaya hai jisme name, description, priority, assigned_to, deadline, aur token
      jaise fields hain. priority mein humne ek selection field rakha hai jo low, medium, aur high options deta hai.
      assigned_to field Many2one relation define karta hai, jo user ko assign karne ke liye hai.</p>

    <h3 class="subsection-title">3. views/task_form_view.xml</h3>
    <p>Yeh file Odoo ke frontend views ko define karti hai. Ismein form view diya gaya hai, jisme user task details
      input kar sakte hain.</p>

    <pre><code class="language-xml">
  &lt;!-- task_form_view.xml --&gt;
  
  &lt;odoo&gt;
    &lt;record id="view_task_form" model="ir.ui.view"&gt;
      &lt;field name="name"&gt;task.form.view&lt;/field&gt;
      &lt;field name="model"&gt;task.management&lt;/field&gt;
      &lt;field name="arch" type="xml"&gt;
        &lt;form string="Task Form"&gt;
          &lt;group&gt;
            &lt;field name="name" /&gt;
            &lt;field name="description" /&gt;
            &lt;field name="priority" /&gt;
            &lt;field name="assigned_to" /&gt;
            &lt;field name="deadline" /&gt;
          &lt;/group&gt;
        &lt;/form&gt;
      &lt;/field&gt;
    &lt;/record&gt;
  &lt;/odoo&gt;
      </code></pre>

    <p><strong>Explanation:</strong></p>
    <p>Yeh form view task creation ke liye hai. name, description, priority, assigned_to, aur deadline ko form mein
      dikhaya gaya hai. &lt;form&gt; tag ke andar yeh fields input karne ke liye available hain.</p>

    <h3 class="subsection-title">4. views/task_tree_view.xml</h3>
    <p>Yeh file tree view ko define karti hai, jisme tasks ko list ke form mein dikhaya jata hai.</p>

    <pre><code class="language-xml">
  &lt;!-- task_tree_view.xml --&gt;
  
  &lt;odoo&gt;
    &lt;record id="view_task_tree" model="ir.ui.view"&gt;
      &lt;field name="name"&gt;task.tree.view&lt;/field&gt;
      &lt;field name="model"&gt;task.management&lt;/field&gt;
      &lt;field name="arch" type="xml"&gt;
        &lt;tree string="Task List"&gt;
          &lt;field name="name" /&gt;
          &lt;field name="priority" /&gt;
          &lt;field name="assigned_to" /&gt;
          &lt;field name="deadline" /&gt;
        &lt;/tree&gt;
      &lt;/field&gt;
    &lt;/record&gt;
  &lt;/odoo&gt;
      </code></pre>

    <p><strong>Explanation:</strong></p>
    <p>Yeh view task list ko tree view format mein dikhata hai. name, priority, assigned_to, aur deadline fields ko
      list mein dikhaya gaya hai.</p>

    <h3 class="subsection-title">5. views/assets.xml</h3>
    <p>Yeh file task module ki static assets ko define karti hai jaise JavaScript aur CSS. Ismein hum frontend pe koi
      custom JS ya CSS use kar sakte hain.</p>

    <pre><code class="language-xml">
  &lt;!-- assets.xml --&gt;
  
  &lt;odoo&gt;
    &lt;template id="assets_backend" name="task_management assets" inherit_id="web.assets_backend"&gt;
      &lt;xpath expr="." position="inside"&gt;
        &lt;script type="text/javascript" src="/task_management/static/src/js/task_management.js"&gt;&lt;/script&gt;
      &lt;/xpath&gt;
    &lt;/template&gt;
  &lt;/odoo&gt;
      </code></pre>

    <p><strong>Explanation:</strong></p>
    <p>Yeh file task management module ke liye custom JavaScript ko include karti hai. JavaScript file
      task_management.js ko hum assets_backend mein add kar rahe hai </p>
    <p>kar rahe hain taaki yeh backend mein load ho.</p>

    <h3 class="subsection-title">6. views/templates.xml</h3>
    <p>Yeh file QWeb templates ko define karti hai jo custom HTML aur UI components ko manage karti hai. QWeb
      templates Odoo ke rendering engine ka part hote hain, jo frontend views ko generate karte hain.</p>

    <pre><code class="language-xml">
  &lt;!-- templates.xml --&gt;
  
  &lt;odoo&gt;
    &lt;template id="task_management_template"&gt;
      &lt;div class="task-template"&gt;
        &lt;h3&gt;Task Details&lt;/h3&gt;
        &lt;p&gt;Name: &lt;span t-esc="task.name"/&gt;&lt;/p&gt;
        &lt;p&gt;Description: &lt;span t-esc="task.description"/&gt;&lt;/p&gt;
        &lt;p&gt;Priority: &lt;span t-esc="task.priority"/&gt;&lt;/p&gt;
        &lt;p&gt;Assigned To: &lt;span t-esc="task.assigned_to.name"/&gt;&lt;/p&gt;
        &lt;p&gt;Deadline: &lt;span t-esc="task.deadline"/&gt;&lt;/p&gt;
      &lt;/div&gt;
    &lt;/template&gt;
  &lt;/odoo&gt;
      </code></pre>

    <p><strong>Explanation:</strong></p>
    <p>Yeh template task details ko show karta hai. Humne task fields ko HTML structure mein display kiya hai, jisme
      task ka name, description, priority, assigned user, aur deadline show kiye gaye hain.</p>

    <h3 class="subsection-title">7. security/ir.model.access.csv</h3>
    <p>Yeh file model access control ko define karti hai, jo kisi user ko kis model ka access hai, isse specify karti
      hai. Yeh file security rules ko configure karne ke liye use hoti hai.</p>

    <pre><code class="language-csv">
  "access_task_management_user","task management user","model_task_management","task_management.group_task_management_user",1,1,1,1
      </code></pre>

    <p><strong>Explanation:</strong></p>
    <p>Yeh access control list task model ke liye hai. Ismein humne task management model ke liye users ko access
      grant kiya hai, jaise "task_management_user" group ko permissions di gayi hain.</p>

    <h3 class="subsection-title">8. static/src/js/task_management.js</h3>
    <p>Yeh JavaScript file task management module ke liye custom functionality ko define karti hai, jo frontend pe
      load hoti hai. Ismein tasks ko handle karne ke liye JavaScript code hote hain.</p>

    <pre><code class="language-javascript">
  /* task_management.js */
  
  odoo.define('task_management.task_management', function (require) {
      "use strict";
  
      var core = require('web.core');
      var Widget = require('web.Widget');
  
      var TaskWidget = Widget.extend({
          start: function () {
              this._super.apply(this, arguments);
              console.log('Task Management Widget Loaded!');
          },
      });
  
      core.action_registry.add('task_management_widget', TaskWidget);
  });
      </code></pre>

    <p><strong>Explanation:</strong></p>
    <p>Yeh JavaScript widget ko define karta hai jo Odoo ki frontend functionality mein use hota hai. Ismein simple
      "TaskWidget" banaya gaya hai, jo load hone par console pe message dikhata hai.</p>

    <h3 class="subsection-title">9. __init__.py</h3>
    <p>Yeh file Python module ke initializations ko define karti hai. Ismein hum module ke imports ko specify karte
      hain taaki system module ko recognize kare.</p>

    <pre><code class="language-python">
  # __init__.py
  
  from . import controllers
  from . import models
      </code></pre>

    <p><strong>Explanation:</strong></p>
    <p>Yeh file Odoo ko batata hai ki kaunse submodules ko import kiya gaya hai, jaise controllers aur models ko.</p>

    <h3 class="subsection-title">10. __manifest__.py</h3>
    <p>Yeh file Odoo module ka manifest hai, jo module ka name, description, version, aur dependencies ko define karti
      hai.</p>

    <pre><code class="language-python">
  # __manifest__.py
  
  {
      'name': 'Task Management',
      'version': '1.0',
      'category': 'Tools',
      'description': 'Manage tasks effectively.',
      'author': 'Your Name',
      'website': 'https://www.example.com',
      'depends': ['base'],
      'data': [
          'views/task_form_view.xml',
          'views/task_tree_view.xml',
          'views/assets.xml',
          'views/templates.xml',
          'security/ir.model.access.csv',
      ],
      'installable': True,
      'auto_install': False,
  }
      </code></pre>

    <p><strong>Explanation:</strong></p>
    <p>Yeh manifest file module ki basic information ko define karti hai. Ismein module ka name, version, aur
      dependencies specified hain. 'data' field mein views aur other files include ki gayi hain.</p>

    <h3 class="subsection-title">11. routes.py</h3>
    <p>Yeh file module ke routes ko handle karti hai. Ismein routes define karte hain jisme user ko different API
      endpoints ya pages ki taraf route kiya jata hai.</p>

    <pre><code class="language-python">
  # routes.py
  
  from odoo import http
  
  class TaskManagementRoutes(http.Controller):
      @http.route('/task/list', auth='public', website=True)
      def task_list(self, **kwargs):
          return http.request.render('task_management.task_list_template')
      </code></pre>

    <p><strong>Explanation:</strong></p>
    <p>Yeh route task list ko display karne ke liye hai. Jab user /task/list URL pe jata hai, toh yeh task list ko
      show karta hai.</p>
  </div>
































  <div class="content">
    <!-- Introduction to Owl (Odoo Web Library) -->
    <h1 class="section-title">Owl (Odoo Web Library) kya hai?</h1>
    <p>
      Owl (Odoo Web Library) ek modern JavaScript framework hai jo Odoo ke frontend development ke liye use hota hai.
      Yeh framework specifically Odoo ke UI ko dynamic aur interactive banane ke liye design kiya gaya hai.
      Owl ka main focus component-based architecture aur reactivity par hota hai, jo complex UIs ko handle karne mein
      madad karta hai.
    </p>

    <!-- Role of Owl in Odoo -->
    <h2 class="subsection-title">Owl ka role Odoo mein</h2>
    <p>
      Owl ka role Odoo mein dynamic UI components render karne ka hota hai, jise reusable components ke roop mein divide
      kiya jata hai.
      Jaise hi data update hota hai, Owl automatically UI ko re-render karta hai, bina page ko reload kiye.
    </p>

    <!-- Why Owl is Important for Odoo Developers -->
    <h2 class="subsection-title">Owl ko samajhna kyun zaroori hai?</h2>
    <p>
      Owl ko samajhna Odoo developers ke liye zaroori hai, kyunki yeh modern aur efficient way hai Odoo UI ko design
      karne ka,
      especially agar aapko interactive web interfaces banani ho.
    </p>

    <!-- Overview of Owl Features -->
    <h2 class="subsection-title">Owl ka Overview aur Features</h2>
    <p><strong>Dynamic UI Rendering:</strong> Jab bhi data update hota hai, Owl uss change ko track karta hai aur UI ko
      automatically update kar leta hai. Isse user ko real-time feedback milta hai bina page ko reload kiye.</p>
    <p><strong>Component-based Architecture:</strong> Odoo mein, Owl har UI element ko ek independent component ke roop
      mein treat karta hai. Yeh component apne state aur methods ko manage karta hai. Jab component ka state change hota
      hai, toh component apne aap apne UI ko update kar leta hai.</p>
    <p><strong>Declarative Syntax:</strong> Owl ka syntax simple aur declarative hota hai. Aap sirf yeh define karte
      hain ki aapko kya dikhana hai, aur Owl apne aap uss cheez ko render kar leta hai.</p>
    <p><strong>Example:</strong> Agar aap ek list view bana rahe hain jisme records ko dynamically load karna hai, toh
      aap Owl components ka use kar sakte hain jo automatically display ko update karte hain jab new records load hote
      hain.</p>

    <!-- Differences Between Owl and Traditional Odoo JS -->
    <h2 class="section-title">Owl aur Traditional Odoo JS (jQuery) ke beech differences</h2>
    <ul>
      <li><strong>Architecture:</strong>
        <p><strong>Owl:</strong> Component-based architecture. Reactivity ka use karta hai, jab data change hota hai, UI
          automatically update ho jata hai.</p>
        <p><strong>Traditional Odoo JS (jQuery):</strong> Imperative-based, jisme aapko manually DOM ko update karna
          padta hai.</p>
      </li>
      <li><strong>Syntax:</strong>
        <p><strong>Owl:</strong> Declarative syntax, jisme aap state ko define karte hain aur template mein bind karte
          hain. Owl automatic update kar leta hai jab state change hota hai.</p>
        <p><strong>Traditional Odoo JS (jQuery):</strong> Imperative syntax, jisme aap manually DOM elements ko update
          karte hain.</p>
      </li>
      <li><strong>DOM Manipulation:</strong>
        <p><strong>Owl:</strong> Virtual DOM ka use karta hai jo efficiently UI ko update karta hai jab state change
          hota hai.</p>
        <p><strong>Traditional Odoo JS (jQuery):</strong> Direct DOM manipulation, jisme har DOM update ko manually
          handle karna padta hai.</p>
      </li>
      <li><strong>Performance:</strong>
        <p><strong>Owl:</strong> Performance optimize hota hai kyunki woh sirf un components ko re-render karta hai jo
          change hue hain.</p>
        <p><strong>Traditional Odoo JS (jQuery):</strong> Less optimized, aapko har DOM element ko manually update karna
          padta hai.</p>
      </li>
      <li><strong>Scalability:</strong>
        <p><strong>Owl:</strong> Highly scalable, component-based approach se code modular aur testable hota hai.</p>
        <p><strong>Traditional Odoo JS (jQuery):</strong> Less scalable, complex UIs banate waqt code cluttered ho sakta
          hai.</p>
      </li>
      <li><strong>Integration with Odoo:</strong>
        <p><strong>Owl:</strong> Native to Odoo, har version mein integrated hai aur Odoo UI mein directly use hota hai.
        </p>
        <p><strong>Traditional Odoo JS (jQuery):</strong> Purane Odoo versions mein use hota tha, lekin ab Owl ko zyada
          prefer kiya jata hai.</p>
      </li>
    </ul>

    <!-- Conclusion -->
    <h2 class="section-title">Conclusion</h2>
    <p>
      Owl ek modern framework hai jo Odoo applications mein dynamic aur reactive UI components create karne mein madad
      karta hai.
      Yeh component-based architecture aur reactivity ka use karta hai, jo complex UIs ko efficiently manage karne mein
      help karta hai.
    </p>

    <!-- Owl Core Concepts -->
    <h2 class="section-title">Owl Core Concepts</h2>
    <p>
      Owl (Odoo Web Library) ek powerful JavaScript framework hai, jo Odoo mein dynamic aur responsive user interfaces
      banane ke liye use hota hai. Owl ka structure component-based aur reactive hota hai, jo UI ko efficiently manage
      karta hai.
    </p>

    <h3 class="subsection-title">1. Components and Views in Owl</h3>
    <p><strong>Components:</strong> Owl mein Component ek reusable unit hota hai jo apne state, template, aur methods ko
      manage karta hai. Har component ko apna independent state hota hai aur jab uska state change hota hai, toh UI
      automatically re-render hota hai.</p>
    <p><strong>State:</strong> Component ka internal data, jo UI ko dynamically update karta hai.</p>
    <p><strong>Methods:</strong> Component ke actions ya behavior ko define karte hain, jaise button click pe kya karna
      hai.</p>
    <p><strong>Template:</strong> Component ka UI structure hota hai, jo XML mein define kiya jata hai.</p>

    <!-- Example of an Owl component -->
    <pre class="highlight"><code class="language-javascript">
        import { Component } from 'owl';
        
        class MyComponent extends Component {
            // Initial state
            state = {
                count: 0  // count variable holds the state of the component
            };
        
            // Method to update the state
            increment() {
                this.state.count += 1;  // Increment count on each button click
            }
        
            // Linking template
            static template = 'my_module.MyComponentTemplate';  // Bind this component to an XML template
        
        }
        
        export default MyComponent;
                </code></pre>

    <p>
      Above code mein, humne ek `MyComponent` banaya hai jisme ek state variable `count` rakha hai. Jab `increment`
      method call hota hai, toh `count` ki value 1 se increment hoti hai. `static template` ka use karke, hum component
      ko ek XML template ke saath link kar rahe hain. Jab `count` state change hoti hai, UI automatically update ho jata
      hai.
    </p>
  </div>










  <!-- Explanation section starts -->
  <div class="content">
    <!-- Title for Explanation Section -->
    <h2 class="section-title">Explanation:</h2>

    <!-- State explanation with inline styling for readability -->
    <p><span class="important">State:</span> Yaha count ek state hai jo UI ko control karta hai.</p>
    <p><span class="important">Methods:</span> increment() method state ko update karta hai.</p>
    <p><span class="important">Template:</span> Template ko link karte hain jisme dynamic rendering hoti hai.</p>

    <!-- Explanation of Views with their role -->
    <h3 class="subsection-title">Views:</h3>
    <p>Views ka role Owl mein UI ko render karna hota hai. Yeh XML templates hoti hain jo OWL component ke sath bind ki
      jati hain.</p>
    <p>Views ko dynamically update kiya jata hai jab component ka state change hota hai.</p>
  </div>

  <!-- Example View Section (XML) -->
  <div class="content">
    <h3 class="subsection-title">Example View (XML):</h3>

    <!-- Code snippet wrapped in <pre> and <code> for syntax highlighting -->
    <pre><code class="language-xml">
&lt;t t-name="my_module.MyComponentTemplate"&gt;
    &lt;div&gt;
        &lt;p t-esc="state.count"&gt; &lt;/p&gt;
        &lt;button t-on-click="increment"&gt; Increase Count&lt;/button&gt;
    &lt;/div&gt;
&lt;/t&gt;
        </code></pre>

    <!-- Explanation of the code -->
    <p><span class="important">Explanation:</span></p>
    <ul>
      <li><code>t-esc="state.count"</code>: Yeh state ke count ko dynamically display karta hai.</li>
      <li><code>t-on-click="increment"</code>: Jab user button pe click karega, increment method call hoga, jo count ko
        update karega.</li>
    </ul>
  </div>

  <!-- The Virtual DOM Concept section starts -->
  <div class="content">
    <h2 class="section-title">2. The Virtual DOM Concept in Owl</h2>
    <p>Owl mein Virtual DOM ka concept use hota hai jo performance ko optimize karta hai.</p>
    <p>Virtual DOM ek in-memory representation hai jo actual DOM ko represent karta hai. Jab bhi state change hota hai,
      Owl apne Virtual DOM ko update karta hai aur fir sirf un parts ko render karta hai jo change hue hain.</p>

    <!-- Real DOM vs Virtual DOM explanation -->
    <h3 class="subsection-title">Real DOM vs Virtual DOM:</h3>
    <p>Jab aap traditional web development (jQuery) mein directly DOM manipulate karte ho, toh har ek DOM update costly
      hota hai. Virtual DOM mein, changes pehle memory mein track kiye jate hain aur fir efficiently diffing algorithm
      ke through changes ko actual DOM mein reflect karte hain.</p>
  </div>

  <!-- Example of Virtual DOM in Owl -->
  <div class="content">
    <h3 class="subsection-title">Example:</h3>

    <!-- Code snippet for Virtual DOM example -->
    <pre><code class="language-javascript">
// State change triggers Virtual DOM update
this.state.count = this.state.count + 1;
        </code></pre>

    <!-- Explanation of the example -->
    <p><span class="important">Explanation:</span></p>
    <p>Jab <code>this.state.count</code> change hota hai, Owl Virtual DOM mein changes track karta hai aur sirf changed
      part ko update karta hai, jisse performance boost hota hai.</p>
  </div>

  <!-- Reactive State section starts -->
  <div class="content">
    <h2 class="section-title">3. Understanding Owl's Reactive State</h2>
    <p>Owl ka reactive state ka concept state management ko simplify karta hai. Jab bhi component ke state mein koi
      change hota hai, Owl automatically uss component ko re-render karta hai. Yeh behavior reactivity ke through manage
      hota hai.</p>

    <!-- Explanation of reactivity -->
    <p>Reactivity ka matlab hai ki jab component ka data (state) change hota hai, toh us data ke saath associated views
      bhi update ho jate hain bina kisi extra effort ke.</p>
  </div>








  <div class="content">
    <h1 class="section-title">Example of Reactive State:</h1>
    <pre class="highlight"><code class="language-javascript">
    import { Component } from 'owl';
    
    class Counter extends Component {
        state = {
            count: 0
        };
    
        increment() {
            this.state.count += 1;
        }
    
        static template = 'my_module.CounterTemplate';
    }
    
    export default Counter;
            </code></pre>
    <p>Explanation:</p>
    <ul>
      <li>Jab <code>this.state.count</code> ko increment kiya jata hai, tab UI automatically update hota hai. Aapko
        manually re-render karne ki zarurat nahi hoti.</li>
    </ul>

    <h2 class="subsection-title">4. Events and Actions Handling in Owl</h2>
    <p>Owl mein events ko handle karna bahut easy hai, aur isme action handlers ka use kiya jata hai jo specific events
      ko handle karte hain, jaise button click ya form submit.</p>

    <h3 class="subsection-title">Events:</h3>
    <p>Owl mein events ko handle karne ke liye <code>t-on-&lt;event&gt;</code> directive ka use hota hai. Jaise
      <code>t-on-click</code>, <code>t-on-change</code>, etc.
    </p>

    <h3 class="subsection-title">Actions:</h3>
    <p>Ye functions hain jo events ke response mein execute hote hain, jaise button click pe function call karna.</p>

    <h4 class="subsection-title">Example: Handling Button Click Event:</h4>
    <pre class="highlight"><code class="language-xml">
    &lt;t t-name="my_module.CounterTemplate"&gt; 
        &lt;div&gt; 
            &lt;p t-esc="state.count"&gt; &lt;/p&gt; 
            &lt;button t-on-click="increment"&gt; Increment&lt;/button&gt; 
        &lt;/div&gt; 
    &lt;/t&gt;
            </code></pre>
    <pre class="highlight"><code class="language-javascript">
    class Counter extends Component {
        state = {
            count: 0
        };
    
        increment() {
            this.state.count += 1;  // Increment the count
        }
    
        static template = 'my_module.CounterTemplate';
    }
            </code></pre>
    <p>Explanation:</p>
    <ul>
      <li><code>t-on-click="increment"</code>: Jab user button pe click karega, increment method call hoga, jo count ko
        increment karega.</li>
    </ul>

    <h2 class="subsection-title">5. Owl Lifecycle Methods</h2>
    <p>Owl mein lifecycle methods hote hain jo component ke life cycle events ko handle karte hain, jaise component ka
      mount hona, update hona, ya unmount hona. Yeh methods allow karte hain ki aap apne component ko efficiently manage
      kar sakein.</p>

    <h3 class="subsection-title">Common Lifecycle Methods:</h3>
    <ul>
      <li><strong>constructor()</strong>: Yeh method component ke creation par call hota hai. Aap isme component ko
        initialize kar sakte hain.</li>
      <li><strong>mounted()</strong>: Yeh method tab call hota hai jab component DOM pe render ho jata hai. Aap
        DOM-related tasks ya side effects yahan handle kar sakte hain.</li>
      <li><strong>updated()</strong>: Jab component ka state update hota hai, tab yeh method call hota hai. Yeh useful
        hota hai jab aapko UI ya external services ko update karna ho.</li>
      <li><strong>unmounted()</strong>: Yeh method tab call hota hai jab component DOM se remove ho jata hai. Yeh
        cleanup tasks ke liye use hota hai.</li>
    </ul>

    <h4 class="subsection-title">Example:</h4>
    <pre class="highlight"><code class="language-javascript">
    constructor() {
        super(...arguments);
        console.log('Component created!');
    }
            </code></pre>
    <pre class="highlight"><code class="language-javascript">
    mounted() {
        console.log('Component mounted on the page!');
    }
            </code></pre>
    <pre class="highlight"><code class="language-javascript">
    updated() {
        console.log('Component updated with new state');
    }
            </code></pre>
    <pre class="highlight"><code class="language-javascript">
    unmounted() {
        console.log('Component removed from the page');
    }
            </code></pre>

    <h4 class="subsection-title">Complete Lifecycle Example:</h4>
    <pre class="highlight"><code class="language-javascript">
    import { Component } from 'owl';
    
    class MyComponent extends Component {
        constructor() {
            super(...arguments);
            console.log('Component created');
        }
    
        mounted() {
            console.log('Component mounted');
        }
    
        updated() {
            console.log('Component updated');
        }
    
        unmounted() {
            console.log('Component unmounted');
        }
    
        static template = 'my_module.MyComponentTemplate';
    }
    
    export default MyComponent;
            </code></pre>
  </div>













  <div class="content">
    <h1 class="section-title">Owl Lifecycle Methods</h1>
    <p>Explanation:</p>
    <ul>
      <li><strong>constructor()</strong>: Component creation ke waqt execute hota hai.</li>
      <li><strong>mounted()</strong>: Component DOM mein render hone ke baad execute hota hai.</li>
      <li><strong>updated()</strong>: Jab component ka state change hota hai, tab execute hota hai.</li>
      <li><strong>unmounted()</strong>: Jab component DOM se remove hota hai, tab execute hota hai.</li>
    </ul>

    <h2 class="subsection-title">Components and Views</h2>
    <p>Components re-usable units hote hain jo apne state aur behavior ko manage karte hain. Views templates define
      karte hain jo component ke state ke hisaab se dynamically render hote hain.</p>

    <h2 class="subsection-title">Virtual DOM</h2>
    <p>Virtual DOM, actual DOM se pehle memory mein changes ko track karta hai. Yeh performance ko optimize karta hai by
      updating only the changed parts of the DOM, instead of re-rendering the whole page.</p>

    <h2 class="subsection-title">Reactive State</h2>
    <p>Owl ka reactive system automatically UI ko update karta hai jab component ka state change hota hai, without any
      manual DOM manipulation.</p>

    <h2 class="subsection-title">Events and Actions</h2>
    <p>Owl mein events ko handle karna easy hota hai with directives like <code>t-on-click</code>,
      <code>t-on-change</code>, etc., and corresponding methods or actions.
    </p>

    <h2 class="subsection-title">Lifecycle Methods</h2>
    <p>Owl ke lifecycle methods, jaise <code>mounted()</code>, <code>updated()</code>, aur <code>unmounted()</code>,
      component ki life cycle events ko handle karte hain, jo aapko component ke behavior ko manage karne mein madad
      karte hain.</p>

    <h2 class="subsection-title">Why Use Owl in Odoo Development?</h2>
    <ul>
      <li><strong>Efficiency:</strong> Owl ki Virtual DOM aur reactivity features UI ko fast aur efficient bana dete
        hain. Aapko manually DOM ko update nahi karna padta, jo development ko simplify karta hai.</li>
      <li><strong>Modularity:</strong> Owl ka component-based architecture aapko UI ko chhote, manageable parts mein
        break karne ki suvidha deta hai, jisse code reusability badhti hai aur testing asaan hoti hai.</li>
      <li><strong>Declarative Syntax:</strong> Owl ka syntax declarative hota hai, jo samajhne aur likhne mein asaan
        hota hai. Aap sirf yeh define karte hain ki aapko kya chahiye, aur Owl apne aap usse manage kar leta hai.</li>
      <li><strong>State Management:</strong> Reactive state se UI ko real-time mein update karna asaan ho jata hai, bina
        manually event handling karne ki zaroorat ke.</li>
      <li><strong>Lifecycle Management:</strong> Owl ke lifecycle methods se aap component ke har phase ko handle kar
        sakte hain, jaise component creation (constructor), mounting (mounted), update (updated), aur unmounting
        (unmounted).</li>
    </ul>

    <h2 class="subsection-title">Creating and Using Owl Components</h2>
    <p>Owl ek component-based framework hai, jisme har UI element ko ek component ke roop mein treat kiya jata hai.
      Components ko design karte waqt, aap unhe re-usable, modular, aur maintainable bana sakte hain. Owl mein
      components ko banane aur use karne ka process simple hai, aur yeh modern web applications mein effective rendering
      aur state management ke liye design kiya gaya hai.</p>

    <h3 class="subsection-title">1. Understanding the Component Class</h3>
    <p>Owl mein, Component class ek base class hai jisse aap apne custom components create karte hain. Yeh class
      component ka core structure define karti hai aur usme several features jaise state management, rendering, aur
      lifecycle methods ko handle karti hai.</p>
    <ul>
      <li><strong>State:</strong> Component ka internal data, jo render function ke through dynamically UI ko control
        karta hai.</li>
      <li><strong>Methods:</strong> Yeh wo functions hain jo component ki actions ko define karte hain, jaise button
        click pe kya hona chahiye.</li>
      <li><strong>Template:</strong> Component ke associated template ko define karta hai.</li>
    </ul>

    <h3 class="subsection-title">Creating a Basic Owl Component</h3>
    <pre class="highlight"><code class="language-javascript">
import { Component } from 'owl';

class MyComponent extends Component {
    state = {
        message: "Hello, Owl!"
    };

    static template = 'my_module.MyComponentTemplate';
}

export default MyComponent;
        </code></pre>
    <p>Explanation:</p>
    <ul>
      <li><strong>state:</strong> Yaha <code>message</code> ek state hai, jo UI mein dynamically dikhayi dega.</li>
      <li><strong>static template:</strong> Ye define karta hai ki component ka template kaunsa hoga (jo XML mein define
        hota hai).</li>
    </ul>

    <h3 class="subsection-title">2. Rendering Static and Dynamic Content using Owl</h3>
    <p>Static Content: Static content wo hota hai jo change nahi hota. Yeh static data aap directly component ke
      template mein define karte hain.</p>
    <p>Dynamic Content: Dynamic content wo hota hai jo state ya props ke hisaab se change hota hai. Jab state change
      hoti hai, Owl automatically uss content ko re-render karta hai.</p>

    <h4 class="subsection-title">Static Content Example:</h4>
    <pre class="highlight"><code class="language-xml">
&lt;t t-name="my_module.MyComponentTemplate"&gt; 
    &lt;div&gt; 
        &lt;h1&gt; Hello World&lt;/h1&gt;  &lt;!-- Static content --&gt; 
    &lt;/div&gt; 
&lt;/t&gt;
        </code></pre>

    <h4 class="subsection-title">Dynamic Content Example:</h4>
    <pre class="highlight"><code class="language-xml">
&lt;t t-name="my_module.MyComponentTemplate"&gt; 
    &lt;div&gt; 
        &lt;h1 t-esc="state.message"&gt; &lt;/h1&gt;  &lt;!-- Dynamic content using state --&gt; 
    &lt;/div&gt; 
&lt;/t&gt;
        </code></pre>
    <p>Explanation:</p>
    <ul>
      <li><strong>Static content:</strong> <code>Hello World</code> ek fixed text hai jo har baar render hoga.</li>
      <li><strong>Dynamic content:</strong> <code>state.message</code> dynamically display hoga aur jab
        <code>state.message</code> update hoga, UI bhi update hoga.
      </li>
    </ul>

    <h3 class="subsection-title">3. Owl Component's Render Function</h3>
    <p>Owl components ka render function UI ko display karne ke liye responsible hota hai. Jab aap state ko change karte
      hain, Owl automatically render function ko call karta hai aur UI ko update karta hai.</p>

    <h4 class="subsection-title">Example of Render Function:</h4>
    <pre class="highlight"><code class="language-javascript">
import { Component } from 'owl';

class MyComponent extends Component {
    state = {
        count: 0
    };

    increment() {
        this.state.count += 1;
        this.render();  // Explicitly calling render (but usually not needed)
    }

    static template = 'my_module.MyComponentTemplate';
}

export default MyComponent;
        </code></pre>
    <p>Explanation:</p>
    <ul>
      <li><strong>render():</strong> Jab increment method call hota hai, state change hota hai aur render function ko
        call kiya jata hai. Par dhyaan rakhein ki Owl automatically <code>render()</code> ko trigger karta hai jab state
        change hota hai.</li>
    </ul>
  </div>















  <div class="content">
    <h1 class="section-title">Owl Templates (Using QWeb Templates and Owl’s JSX-style Syntax)</h1>
    <p>Owl mein templates ko QWeb templates aur JSX-style syntax dono mein likha ja sakta hai.</p>

    <!-- Subsection A: QWeb Templates -->
    <div class="subsection-title">A. QWeb Templates:</div>
    <p>QWeb templates Odoo ka default templating engine hai. Yeh XML-based syntax use karta hai aur Owl ke components ko
      HTML views se bind karta hai.</p>

    <!-- Example of QWeb Template -->
    <div class="highlight">
      <pre><code class="language-xml">
&lt;t t-name="my_module.MyComponentTemplate"&gt; 
    &lt;div&gt; 
        &lt;button t-on-click="increment"&gt; Increment Count&lt;/button&gt; 
        &lt;p&gt; Count: &lt;span t-esc="state.count"&gt; &lt;/span&gt; &lt;/p&gt; 
    &lt;/div&gt; 
&lt;/t&gt;
            </code></pre>
    </div>
    <p class="important">Explanation:</p>
    <ul>
      <li><b>t-on-click="increment"</b>: Jab user button pe click karega, increment function call hoga.</li>
      <li><b>t-esc="state.count"</b>: Yeh dynamically count ko display karega, jo state.count ke value ke according
        update hota hai.</li>
    </ul>

    <!-- Subsection B: Owl’s JSX-style Syntax -->
    <div class="subsection-title">B. Owl’s JSX-style Syntax:</div>
    <p>Owl ka JSX-style syntax JavaScript ke andar HTML ko embed karne ki suvidha deta hai. Yeh React ke JSX syntax se
      milta-julta hai, jisme JavaScript code ke andar HTML components define kiye jate hain.</p>

    <!-- Example of Owl JSX-style Template -->
    <div class="highlight">
      <pre><code class="language-javascript">
import { Component } from 'owl';

class MyComponent extends Component {
    state = {
        count: 0
    };

    increment() {
        this.state.count += 1;
    }

    render() {
        return (
            &lt;div&gt; 
                &lt;button onClick={() =&gt;  this.increment()}&gt; Increment Count&lt;/button&gt; 
                &lt;p&gt; Count: {this.state.count}&lt;/p&gt; 
            &lt;/div&gt; 
        );
    }
}

export default MyComponent;
            </code></pre>
    </div>
    <p class="important">Explanation:</p>
    <ul>
      <li><b>JSX Syntax:</b> Yaha &lt;div&gt; , &lt;button&gt; , aur &lt;p&gt; HTML elements directly JavaScript ke
        andar likhe gaye hain. State ko {this.state.count} ke through dynamically render kiya gaya hai.</li>
    </ul>

    <!-- Comparison between QWeb and JSX-style Syntax in Owl -->
    <h2 class="subsection-title">Comparison: QWeb vs JSX-style Syntax in Owl</h2>
    <table>
      <thead>
        <tr>
          <th>Feature</th>
          <th>QWeb Templates</th>
          <th>JSX-style Syntax</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Syntax</td>
          <td>XML-based templating engine</td>
          <td>JavaScript mein HTML-like syntax</td>
        </tr>
        <tr>
          <td>Binding</td>
          <td>t-esc, t-on-click, etc. for dynamic content</td>
          <td>{this.state.count}, onClick={}</td>
        </tr>
        <tr>
          <td>Use Case</td>
          <td>Suitable for Odoo modules, better integration</td>
          <td>More flexible, more JavaScript-centric</td>
        </tr>
        <tr>
          <td>Render Logic</td>
          <td>Handled by Owl automatically</td>
          <td>Requires explicit function call for updates</td>
        </tr>
        <tr>
          <td>Integration</td>
          <td>Ideal for Odoo views and templates</td>
          <td>Ideal for more dynamic and complex components</td>
        </tr>
      </tbody>
    </table>

    <!-- Conclusion Section -->
    <p class="section-title">Conclusion:</p>
    <p>Owl mein components ko use karna kaafi straightforward hai aur aap apne applications ko modular aur re-usable
      bana sakte hain. Key concepts jaise state management, rendering static and dynamic content, aur JSX-style
      templates se aap easily interactive aur dynamic UIs create kar sakte hain.</p>

    <!-- Section on Component Class, Render Function, Templates -->
    <div class="subsection-title">Component Class, Render Function, Templates</div>
    <p>Component ek class hoti hai jisme state aur methods hote hain. Yeh function component ka UI render karta hai, aur
      jab state change hoti hai, tab yeh automatically re-render hota hai. Aap templates ko QWeb (XML-based) ya
      JSX-style (JavaScript-based) syntax mein likh sakte hain.</p>

    <!-- State Management in Owl Section -->
    <h2 class="section-title">State Management in Owl</h2>
    <p>Owl mein state management ek essential concept hai jo aapko component ke data ko manage karne mein madad karta
      hai. Jab aap kisi component ka state manage karte hain, toh aap UI ko dynamically control karte hain, jise user ke
      interaction ya kisi external data ke base par update kiya ja sakta hai.</p>

    <!-- Using useState and useRef for Managing Component States -->
    <h3 class="subsection-title">1. Using useState and useRef for Managing Component States</h3>
    <p><b>useState:</b> Yeh hook component ke internal state ko manage karta hai. Isse aap variable ko declare kar sakte
      hain jo component ke lifecycle ke dauraan change hota hai, aur jab state change hoti hai, tab component
      automatically re-render hota hai.</p>

    <!-- Example of useState -->
    <div class="highlight">
      <pre><code class="language-javascript">
import { useState, Component } from 'owl';

class CounterComponent extends Component {
    constructor() {
        super();
        this.state = useState({
            count: 0
        });
    }

    increment() {
        this.state.count += 1;
    }

    decrement() {
        this.state.count -= 1;
    }

    static template = 'my_module.CounterTemplate';
}

export default CounterComponent;
            </code></pre>
    </div>
    <p class="important">Explanation:</p>
    <ul>
      <li><b>useState:</b> Humne count ko state ke roop mein initialize kiya hai. Jab count update hota hai, UI
        automatically re-render hota hai.</li>
    </ul>

    <!-- Example of useRef -->
    <h3 class="subsection-title">Example of useRef</h3>
    <div class="highlight">
      <pre><code class="language-javascript">
import { useRef, Component } from 'owl';

class MyComponent extends Component {
    constructor() {
        super();
        this.myButton = useRef(null);
    }

    focusButton() {
        this.myButton.el.focus();
    }

    static template = 'my_module.MyComponentTemplate';
}

export default MyComponent;
            </code></pre>
    </div>
    <p class="important">Explanation:</p>
    <ul>
      <li><b>useRef:</b> Humne myButton ko reference karne ke liye use kiya hai, jo button ko directly focus karne mein
        madad karta hai.</li>
    </ul>
  </div>













  <div class="content">
    <!-- Section Title: Using Context -->
    <h2 class="section-title">Using Context:</h2>
    <p>
      Context ka use karne ke liye aap <strong>useContext</strong> hook ka use karte hain, jisse parent component ka
      state ya shared data child component tak easily accessible ho jata hai.
    </p>

    <pre class="highlight">
                <code class="language-javascript">
    import { Component, useState, useContext } from 'owl';
    
    const MyContext = useContext();
    
    class ParentComponent extends Component {
        constructor() {
            super();
            // Context value set karna
            this.state = useState({ user: 'John Doe' });
        }
    
        static template = 'my_module.ParentTemplate';
    
        static provide = {
            user: this.state.user
        };
    }
    
    class ChildComponent extends Component {
        static template = 'my_module.ChildTemplate';
    
        render() {
            // Context se value read karna
            const user = this.env.user;
            return (
                &lt;div&gt; 
                    &lt;p&gt; User: {user}&lt;/p&gt;  {/* Accessing context */}
                &lt;/div&gt; 
            );
        }
    }
                </code>
            </pre>

    <!-- Explanation Section -->
    <h3 class="subsection-title">Explanation:</h3>
    <ul>
      <li><strong>useContext</strong> hook ka use parent component se context value ko read karne ke liye hota hai, aur
        child components ko wo data easily accessible hota hai.</li>
      <li><strong>provide</strong>: Parent component mein state ya context value ko provide karna.</li>
      <li><strong>env.user</strong>: Child component mein context ko access karna.</li>
    </ul>

    <!-- Recap Section -->
    <h3 class="subsection-title">Recap and Conclusion:</h3>
    <p>
      Owl mein state management ko efficiently handle karne ke liye aapko <strong>useState</strong>,
      <strong>useRef</strong>, reactive variables, props, aur context ka use seekhna zaroori hai.
    </p>
    <ul>
      <li><strong>useState</strong>: Component ke internal state ko manage karta hai.</li>
      <li><strong>useRef</strong>: Persistent mutable references ko store karta hai, jaise DOM elements.</li>
      <li><strong>Reactive Variables</strong>: State change ke sath UI ko automatically update karta hai.</li>
      <li><strong>Props</strong>: Parent se child component ko data pass karne ka tareeka hai.</li>
      <li><strong>Context</strong>: Large applications mein shared data ko across components pass karne ka ek efficient
        tareeka hai.</li>
    </ul>

    <!-- Context ka Concept Section -->
    <h3 class="subsection-title">Context ka Concept:</h3>
    <p>
      Owl mein Context ek container ke roop mein hota hai jisme aap global or shared data ko store kar sakte hain.
      Parent component is data ko provide karta hai, aur child components consume karte hain. Isse ek hierarchy form
      hoti hai jisme top-level component se data ko niche ke components tak easily pass kiya ja sakta hai, bina har
      child ko explicitly props pass kiye.
    </p>

    <pre class="highlight">
                <code class="language-javascript">
    Provide: Parent component context ko provide karta hai.
    Consume: Child component context ko consume karta hai.
                </code>
            </pre>

    <!-- Context ka Use Case Section -->
    <h3 class="subsection-title">Context ka Use Case:</h3>
    <p>
      Consider kariye ek scenario jahan ek parent component hai jisme user details (jaise username, role, etc.) stored
      hain, aur aapko yeh data multiple child components mein chahiye. Aap har child ko directly props pass karne ki
      bajaye, context ka use karke yeh data share kar sakte hain.
    </p>

    <!-- How Context Works in Owl Section -->
    <h3 class="subsection-title">How Context Works in Owl:</h3>
    <ul>
      <li><strong>Creating Context:</strong> Aap <code>useContext</code> hook ko use karte hain context create karne ke
        liye.</li>
      <li><strong>Providing Context:</strong> Parent component mein <code>provide</code> property ka use hota hai, jisme
        aap context ke values ko define karte hain.</li>
      <li><strong>Consuming Context:</strong> Child components mein <code>useContext</code> hook ko use karke context ko
        access kiya ja sakta hai.</li>
    </ul>

    <!-- Example of Using Context in Owl Section -->
    <h3 class="subsection-title">Example of Using Context in Owl:</h3>

    <!-- Step 1: Define Context in Parent Component -->
    <h4 class="subsection-title">Step 1: Define Context in Parent Component</h4>
    <p>
      Sabse pehle, aap parent component mein context ko define karenge. Yeh context kisi shared data ko store karega jo
      aap child components ke saath share karna chahte hain.
    </p>
    <pre class="highlight">
                <code class="language-javascript">
    import { Component, useState } from 'owl';
    
    // Parent Component
    class ParentComponent extends Component {
        constructor() {
            super();
            // Context data define karna
            this.state = useState({
                user: { name: "John Doe", role: "Admin" }
            });
        }
    
        static template = 'my_module.ParentTemplate';
    
        // Providing context to child components
        static provide = {
            user: this.state.user
        };
    }
    
    export default ParentComponent;
                </code>
            </pre>

    <!-- Step 2: Consume Context in Child Component -->
    <h4 class="subsection-title">Step 2: Consume Context in Child Component</h4>
    <p>
      Ab, child component mein context ko consume karte hain. Yeh aapko <code>useContext</code> hook ke through milta
      hai.
    </p>
    <pre class="highlight">
                <code class="language-javascript">
    import { Component, useContext } from 'owl';
    
    // Child Component
    class ChildComponent extends Component {
        constructor() {
            super();
            // Consuming context data in child component
            this.user = useContext('user');
        }
    
        static template = 'my_module.ChildTemplate';
    
        render() {
            return (
                &lt;div&gt; 
                    &lt;p&gt; User Name: {this.user.name}&lt;/p&gt;   {/* Displaying user's name */}
                    &lt;p&gt; User Role: {this.user.role}&lt;/p&gt;   {/* Displaying user's role */}
                &lt;/div&gt; 
            );
        }
    }
    
    export default ChildComponent;
                </code>
            </pre>

    <!-- Step 3: Parent and Child Components Together -->
    <h4 class="subsection-title">Step 3: Parent and Child Components Together</h4>
    <p>
      Parent aur child components ko aise connect kiya jata hai:
    </p>
    <pre class="highlight">
                <code class="language-xml">
    &lt;template&gt; 
        &lt;div&gt; 
            &lt;ParentComponent&gt; 
                &lt;ChildComponent /&gt; 
            &lt;/ParentComponent&gt; 
        &lt;/div&gt; 
    &lt;/template&gt;
                </code>
            </pre>

    <!-- Context in Action Section -->
    <h3 class="subsection-title">Context in Action:</h3>
    <p>
      Agar aap context ko effectively use karte hain, toh aapke application ka state management kaafi efficient ho jata
      hai. Aapko props ko manually pass karne ki zaroorat nahi padti hai, aur aap easily shared state ko handle kar
      sakte hain across multiple components.
    </p>

    <!-- Key Concepts of Context Section -->
    <h3 class="subsection-title">Key Concepts of Context:</h3>
    <ul>
      <li><strong>Provide and Consume:</strong></li>
      <ul>
        <li><strong>Provide:</strong> Parent component ke pass state hoti hai jo uske child components ko diya jata hai.
        </li>
        <li><strong>Consume:</strong> Child components woh data directly context ke through access karte hain.</li>
      </ul>
    </ul>
    <p>
      Context ko use karte waqt, yeh important hai ki aap ek global shared state maintain karte hain. Yeh large-scale
      applications ke liye useful hai jahan same data ko kai jagah use karna hota hai.
    </p>
  </div>



  <div class="content">
    <h1>Data Flow in Context</h1>
    <p><strong>Data Flow:</strong> Context ka use karke, aap ek hierarchical data flow create karte hain jahan top-level
      component se data niche ke components tak effortlessly propagate hota hai.</p>
    <p><strong>Simplifying State Management:</strong> Context, props drilling (props ko nested components mein pass
      karna) ko avoid karta hai, jise maintain karna complex ho sakta hai.</p>

    <h2>Practical Use Case Example:</h2>
    <p>Aap kisi e-commerce application mein imagine kar sakte hain jahan user ka authentication status across multiple
      pages ya components ko required hota hai. Aap context ka use kar ke user ke authentication status ko parent
      component se child components mein easily share kar sakte hain.</p>

    <h2>Context for Authentication:</h2>
    <ul>
      <li>ParentComponent mein isAuthenticated flag ko provide karenge.</li>
      <li>Child components jaise HeaderComponent, ProfileComponent, ya CartComponent ko authentication status ko consume
        karna hoga taaki wo apne content ko accordingly render kar sake.</li>
    </ul>

    <h3>Recap and Conclusion:</h3>
    <p>Owl mein Context ek powerful concept hai jo aapko shared state ko manage karne mein madad karta hai. Yeh
      specially useful hota hai jab aapke paas multiple components hote hain jo same data ko consume karte hain.</p>
    <ul>
      <li><strong>provide:</strong> Parent component se child components ko data provide karne ka tareeka.</li>
      <li><strong>useContext:</strong> Child component mein shared data ko consume karna.</li>
      <li><strong>Context ka use:</strong> Large applications mein state ko manage karte waqt props drilling ko avoid
        karta hai aur code ko simple banata hai.</li>
    </ul>

    <h1>Setting Up Odoo for JavaScript Development</h1>
    <p>Odoo mein JavaScript development start karne ke liye aapko kuch initial setup ki zaroorat hoti hai taaki aap apne
      custom JavaScript code ko Odoo mein efficiently implement kar sakein. Odoo ek powerful ERP system hai jo Python ke
      backend aur JavaScript ke frontend ko combine karke kaafi interactive user interfaces provide karta hai.
      JavaScript ka use karte waqt aapko Odoo ke built-in libraries aur frameworks (jaise Owl aur jQuery) ko samajhna
      zaroori hota hai.</p>

    <p>Is guide mein hum Odoo ke liye JavaScript development setup karne ke complete process ko samjhenge.</p>

    <h2>Step 1: Install and Configure Odoo</h2>
    <p>Sabse pehle, Odoo ka development environment setup karna hoga.</p>

    <h3>Install Odoo:</h3>
    <p>Odoo ko install karne ke liye sabse pehle aapko Python aur PostgreSQL ka installation karna hoga. Aap Odoo ko
      directly GitHub se clone kar sakte hain, ya Odoo's official website se install kar sakte hain. Odoo ko install
      karne ke liye command line se yeh commands run karein:</p>

    <pre><code class="language-bash">
    git clone https://www.github.com/odoo/odoo --branch 16.0 --single-branch --depth 1
    cd odoo
    pip install -r requirements.txt
    python odoo-bin -d my_database --init=base
            </code></pre>

    <p>Iske baad, Odoo ka instance browser par access karne ke liye:</p>
    <pre><code class="language-bash">
    python odoo-bin
            </code></pre>
    <p><strong>Note:</strong> Ensure aapke system mein Python aur PostgreSQL installed hon.</p>

    <h3>Run Odoo Server:</h3>
    <p>Aapko Odoo server ko run karna hoga jisme aap apne custom modules develop karenge. Server ko start karne ke liye
      command:</p>
    <pre><code class="language-bash">
    ./odoo-bin -d my_database
            </code></pre>

    <h2>Step 2: Setting Up Custom Modules for JavaScript Development</h2>
    <p>Aap apne custom JavaScript code ko ek module ke andar implement kar sakte hain. Odoo mein modules ek tarah se
      isolated environment create karte hain jahan pe aap apne custom functionalities ko easily manage kar sakte hain.
    </p>

    <h3>Create a New Odoo Module:</h3>
    <p>Sabse pehle, apne custom module ko create karte hain:</p>
    <pre><code class="language-bash">
    odoo-bin scaffold my_custom_module /path/to/your/addons/
            </code></pre>
    <p>Isse ek my_custom_module naam ka folder create ho jayega jisme basic module structure setup ho jayega.</p>

    <h3>Module Structure:</h3>
    <p>Ek basic Odoo module structure kuch is tarah dikhega:</p>
    <pre><code class="language-markdown">
    my_custom_module/
    ├── __init__.py
    ├── __manifest__.py
    ├── controllers/
    ├── models/
    ├── static/
    │   └── src/
    │       ├── css/
    │       ├── js/
    │       └── xml/
    └── views/
            </code></pre>
    <ul>
      <li><strong>__manifest__.py:</strong> Ye module ka configuration file hota hai jisme aap module ka naam, version,
        description aur dependencies specify karte hain.</li>
      <li><strong>static/js/:</strong> Yeh folder aapke JavaScript files ke liye hota hai.</li>
      <li><strong>views/:</strong> Yaha aap Odoo ka QWeb templates, XML views define karte hain.</li>
    </ul>

    <h2>Step 3: Add JavaScript Code to Your Module</h2>
    <p>Ab, hum apne custom module mein JavaScript code add karenge.</p>

    <h3>Create JS File:</h3>
    <p>Aapko static/src/js folder mein apna JavaScript file banana hoga. Jaise my_script.js.</p>
    <pre><code class="language-javascript">
    // my_custom_module/static/src/js/my_script.js
    odoo.define('my_custom_module.my_script', function (require) {
        "use strict";
    
        var core = require('web.core');
        var Widget = require('web.Widget');
        var _t = core._t;
    
        var MyWidget = Widget.extend({
            template: 'my_custom_module.MyWidgetTemplate',
            events: {
                'click .my_button': '_onButtonClick'
            },
            init: function (parent, options) {
                this._super(parent, options);
            },
            _onButtonClick: function () {
                alert(_t("Button clicked!"));
            }
        });
    
        core.action_registry.add('my_custom_widget', MyWidget);
    });
            </code></pre>

    <p><strong>Explanation:</strong></p>
    <ul>
      <li><strong>odoo.define:</strong> Ye method Odoo mein JavaScript modules ko define karne ka tareeka hai. Yaha, hum
        apne module ko my_custom_module.my_script ke naam se define kar rahe hain.</li>
      <li><strong>Widget.extend:</strong> Odoo mein UI components ko widgets ke through extend kiya jata hai. Hum yaha
        ek custom widget MyWidget create kar rahe hain.</li>
      <li><strong>_onButtonClick:</strong> Is method mein hum button click event ko handle kar rahe hain, jab user
        button click karega, ek alert show hoga.</li>
    </ul>

    <h2>Adding JavaScript to QWeb Template</h2>
    <p>JavaScript code ko view mein use karne ke liye aapko QWeb templates mein isko link karna hoga.</p>
    <pre><code class="language-xml">
    <!-- my_custom_module/static/src/xml/my_widget_template.xml --> 
    <templates> 
        <t t-name="my_custom_module.MyWidgetTemplate"> 
            <button class="my_button"> Click Me</button> 
        </t> 
    </templates> 
            </code></pre>

    <p><strong>Explanation:</strong></p>
    <p>Is XML file mein hum apne widget ka template define kar rahe hain. Ek simple button banaya gaya hai jisko
      .my_button class di gayi hai.</p>

    <h2>Step 4: Load JavaScript in Your Odoo Views</h2>
    <p>JavaScript code ko views mein load karna hoga. Aapko assets ka use karte hue apne JavaScript ko load karna hoga,
      jo manifest file mein define hota hai.</p>

    <h3>Update Manifest File:</h3>
    <pre><code class="language-python">
    # my_custom_module/__manifest__.py
    {
        'name': 'My Custom Module',
        'version': '1.0',
        'category': 'Custom',
        'description': 'Custom JS Development in Odoo',
        'author': 'Your Name',
        'depends': ['web'],
        'data': [
            'views/my_widget_template.xml',
        ],
        'qweb': [
            'static/src/xml/my_widget_template.xml',
        ],
        'assets': {
            'web.assets_backend': [
                'my_custom_module/static/src/js/my_script.js',
            ],
        },
    }
            </code></pre>

    <p>Yeh setup ensure karega ki jab Odoo backend ya front-end load ho, aapka JavaScript code automatically load ho
      jayega aur aapke template ko interactive banayega.</p>

    <h2>Conclusion</h2>
    <p>Odoo mein JavaScript ka istemal karne ka tareeka simple hai, bas aapko sahi structure aur Odoo ke tools ka
      istemal karna zaroori hai. Is guide mein humne step-by-step process dekha hai kaise aap apne custom JavaScript ko
      Odoo mein implement kar sakte hain. Yeh setup aapke custom functionalities ko Odoo mein seamlessly integrate
      karega.</p>
  </div>





















  <div class="content">
    <h1>Step 5: Debugging and Testing JavaScript in Odoo</h1>
    <p>JavaScript development karte waqt aapko apne code ko debug karna bhi zaroori hota hai.</p>

    <h2 class="section-title">Console Logging:</h2>
    <p>JavaScript mein <code>console.log()</code> ka use karke aap apne variables ya events ko debug kar sakte hain.</p>
    <pre class="highlight"><code class="language-javascript">
        _onButtonClick: function () {
            console.log("Button clicked!");
            alert(_t("Button clicked!"));
        }
                </code></pre>

    <h2 class="section-title">Browser Developer Tools:</h2>
    <p>Browser ke developer tools ko use karte hue aap JavaScript errors aur network requests ko inspect kar sakte hain.
    </p>

    <h2 class="subsection-title">Working with QWeb (Odoo's Templating Engine) for Owl Components</h2>
    <p>QWeb ko use karna Odoo mein Owl components ko render karne ka ek common tareeka hai. QWeb templates ko Owl ke
      saath integrate kar ke dynamic UI components ko efficiently render kiya ja sakta hai.</p>

    <h3 class="subsection-title">How QWeb Works with Owl:</h3>
    <h4 class="subsection-title">QWeb Templates:</h4>
    <p>QWeb templates XML files mein define kiye jate hain. Yeh templates dynamic data ko render karne ke liye use hote
      hain.</p>
    <pre class="highlight"><code class="language-xml">
        &lt;templates&gt; 
            &lt;t t-name="my_module.my_template"&gt; 
                &lt;div&gt; 
                    &lt;h1&gt; Hello, &lt;t t-esc="user_name"/&gt; !&lt;/h1&gt; 
                &lt;/div&gt; 
            &lt;/t&gt; 
        &lt;/templates&gt; 
                </code></pre>
    <p>Explanation:</p>
    <ul>
      <li><code>t-name</code>: Yeh template ka unique identifier hai.</li>
      <li><code>t-esc</code>: Yeh method dynamic content ko safely escape karne ke liye use hota hai (jaise user_name ko
        display karna).</li>
    </ul>

    <h4 class="subsection-title">Using Owl with QWeb Templates:</h4>
    <p>Aap Owl component mein QWeb templates ko use kar sakte hain taaki unhe efficiently render kar sakein.</p>
    <pre class="highlight"><code class="language-javascript">
        odoo.define('my_custom_module.my_owl_component', function (require) {
            "use strict";
        
            var AbstractComponent = require('web.AbstractComponent');
            var registry = require('web.component_registry');
            var core = require('web.core');
            var _t = core._t;
        
            var MyOwlComponent = AbstractComponent.extend({
                template: 'my_module.my_template',
                props: {
                    user_name: String,
                },
            });
        
            registry.add('my_custom_component', MyOwlComponent);
        });
                </code></pre>
    <p>Explanation:</p>
    <ul>
      <li><code>template</code>: Is property mein aap QWeb template ka naam set karte hain.</li>
      <li><code>props</code>: Yahan aap component ke props ko define karte hain (jaise user_name).</li>
    </ul>

    <h2 class="subsection-title">3. Understanding Odoo's Static Files Structure (JS, CSS) for Owl</h2>
    <p>Odoo mein static files (JavaScript, CSS) ko static/ directory ke andar organize kiya jata hai. Jab aap Owl
      components develop karte hain, toh aapko apne JS aur CSS files ko module ke static folder mein rakhna padta hai.
    </p>

    <h3 class="subsection-title">Structure of Static Files:</h3>
    <p>Odoo mein static files ka structure kuch is tarah hota hai:</p>
    <pre class="highlight"><code class="language-scss">
        my_custom_module/
        ├── static/
        │   ├── src/
        │   │   ├── css/
        │   │   │   └── style.css
        │   │   ├── js/
        │   │   │   └── my_owl_component.js
        │   │   └── xml/
        ├── __manifest__.py
        ├── models/
        ├── views/
        └── controllers/
                </code></pre>
    <p>Explanation:</p>
    <ul>
      <li><code>static/</code>: Yeh directory aapko apne JS aur CSS files ko store karne ke liye use karni hoti hai.
      </li>
      <li><code>css/</code>: Stylesheets ko store karne ke liye.</li>
      <li><code>js/</code>: JavaScript files ko store karne ke liye, jisme Owl components included hote hain.</li>
      <li><code>xml/</code>: QWeb templates ko store karte hain.</li>
    </ul>

    <h3 class="subsection-title">Linking Static Files in __manifest__.py:</h3>
    <p>Aapko <code>__manifest__.py</code> file mein static files ko include karna padta hai.</p>
    <pre class="highlight"><code class="language-python">
        {
            'name': 'My Custom Owl Module',
            'version': '1.0',
            'category': 'Custom',
            'description': 'Using Owl for custom frontend in Odoo',
            'author': 'Your Name',
            'depends': ['web'],
            'data': [
                'views/my_template.xml',
            ],
            'assets': {
                'web.assets_backend': [
                    'my_custom_module/static/src/js/my_owl_component.js',
                    'my_custom_module/static/src/css/style.css',
                ],
            },
        }
                </code></pre>
    <p>Explanation:</p>
    <ul>
      <li><code>assets</code>: Is section mein aap apne JavaScript aur CSS files ko include karte hain taaki woh Odoo ke
        frontend mein load ho sakein.</li>
    </ul>

    <h2 class="subsection-title">4. Using Odoo Shell and the Debugger for Owl JavaScript Development</h2>
    <p>Odoo mein JavaScript code ko test aur debug karne ke liye aap Odoo shell aur browser ke developer tools ka use
      kar sakte hain. Jab aap Owl framework mein kaam karte hain, debugging tools ka istemal aapke liye bahut useful
      hota hai.</p>

    <h3 class="subsection-title">Using Odoo Shell:</h3>
    <p>Odoo shell ek interactive Python shell hai jisme aap Odoo models ko test kar sakte hain.</p>
    <p><strong>Launch Odoo Shell:</strong> Odoo shell ko launch karne ke liye:</p>
    <pre class="highlight"><code class="language-bash">
        python3 odoo-bin shell
                </code></pre>
    <p>Yeh aapko Odoo environment mein ek interactive shell dega jahan se aap queries run kar sakte hain.</p>

    <h3 class="subsection-title">Using Browser Developer Tools for JavaScript Debugging:</h3>
    <p>Browser ke Developer Tools (F12) ko use kar ke aap apne Owl component code ko debug kar sakte hain. Aap
      breakpoints set kar ke JavaScript execution ko pause kar sakte hain aur variable values inspect kar sakte hain.
    </p>
    <p><strong>Example of debugging JavaScript in Owl:</strong></p>
    <pre class="highlight"><code class="language-javascript">
        odoo.define('my_custom_module.my_owl_component', function (require) {
            "use strict";
        
            var AbstractComponent = require('web.AbstractComponent');
            var registry = require('web.component_registry');
            var core = require('web.core');
            var _t = core._t;
        
            var MyOwlComponent = AbstractComponent.extend({
                template: 'my_module.my_template',
                props: {
                    user_name: String,
                },
        
                init: function () {
                    this._super();
                    debugger;  // Add breakpoint here to inspect code execution
                },
            });
        
            registry.add('my_custom_component', MyOwlComponent);
        });
                </code></pre>
  </div>











  <div class="content">
    <h1>Debugging JavaScript in Odoo</h1>

    <p>JavaScript code ko browser ke developer tools aur Odoo shell ka use karke efficiently debug kar sakte hain.</p>

    <div class="section-title">1. Introduction to Odoo's Web Client</div>
    <p>Odoo ka web client browser ke andar run karta hai aur user interface ko render karta hai. User jo bhi action
      perform karta hai, wo backend ke saath connect hota hai aur data ko dynamically update karta hai. Odoo ka web
      client mainly teen cheezon ka use karta hai:</p>

    <ul>
      <li><strong>Views:</strong> Ye layouts hain jo user ko data dikhate hain, jaise form views, list views, kanban
        views, etc.</li>
      <li><strong>Actions:</strong> Ye operations hain jo views ko open karne ya kisi task ko perform karne ka kaam
        karte hain.</li>
      <li><strong>Widgets:</strong> Ye interactive UI elements hote hain, jaise buttons, input fields, dropdowns,
        tables, etc., jo user interactions ko handle karte hain.</li>
    </ul>

    <div class="subsection-title">Example: Simple Action and View Definition</div>
    <p>Odoo ke web client mein views aur actions ka interaction hota hai. Action ek specific task ko trigger karta hai,
      jisme ek view load hota hai.</p>

    <p>Maan lijiye hum employee form ko open karna chahte hain, to ek action definition is tarah hogi:</p>

    <pre><code class="language-xml">
            &lt;odoo&gt; 
                &lt;!-- Action jo form view ko open karega --&gt; 
                &lt;record id="action_employee_form" model="ir.actions.act_window"&gt; 
                    &lt;field name="name"&gt; Employee Form&lt;/field&gt; 
                    &lt;field name="res_model"&gt; hr.employee&lt;/field&gt; 
                    &lt;field name="view_mode"&gt; form&lt;/field&gt;  &lt;!-- Form view ko open karne ka option --&gt; 
                    &lt;field name="view_id" ref="view_employee_form"/&gt;  &lt;!-- Form view ka reference --&gt; 
                &lt;/record&gt; 
            &lt;/odoo&gt; 
                    </code></pre>

    <p><strong>Explanation:</strong></p>
    <ul>
      <li><strong>&lt;record&gt;:</strong> Ye action ko define karta hai, jo user ko employee ka form view dikhata hai.
      </li>
      <li><strong>&lt;field name="view_mode"&gt; form&lt;/field&gt;:</strong> Ye action ko form view mode mein render
        karta hai.</li>
      <li><strong>&lt;field name="view_id" ref="view_employee_form"&gt;:</strong> Ye action ko specific form view
        (view_employee_form) ke saath link karta hai.</li>
    </ul>

    <p>Jab user is action ko trigger karega, employee form view open ho jayega.</p>

    <div class="section-title">2. Understanding the Web Client’s Widget-Based Architecture</div>
    <p>Odoo ka widget-based architecture ek modular aur reusable structure provide karta hai. Har ek component ko ek
      widget manage karta hai. Widget ek JavaScript object hai jo kisi specific UI element ko handle karta hai. Jaise
      agar aapko ek custom button banana hai, to uske liye ek widget banate hain jo button ko render karega aur uske
      interaction ko manage karega.</p>

    <div class="subsection-title">Key Features of Widgets in Odoo</div>
    <ul>
      <li><strong>Encapsulation:</strong> Har widget apne behavior aur state ko encapsulate karta hai, jisse wo
        modularity aur reusability ko support karta hai.</li>
      <li><strong>Reusability:</strong> Ek widget ko kai jagah reuse kiya ja sakta hai bina kisi major change ke.</li>
      <li><strong>Interactivity:</strong> Ye widgets user ke actions ko handle karte hain aur UI ko dynamically update
        karte hain.</li>
    </ul>

    <div class="subsection-title">Example: A Custom Button Widget</div>
    <p>Maan lijiye, hum ek simple custom button widget create karte hain jo user ko button pe click karne par alert
      message dikhata hai.</p>

    <pre><code class="language-javascript">
            odoo.define('my_module.CustomButtonWidget', function (require) {
                var AbstractAction = require('web.AbstractAction');  // Importing base class for custom actions
                var core = require('web.core');  // Core functionalities of Odoo
                var QWeb = core.qweb;  // Template rendering engine
            
                var CustomButtonWidget = AbstractAction.extend({
                    template: 'my_module.CustomButtonWidgetTemplate',  // Template for the widget
            
                    events: {
                        'click .my_button': 'onButtonClick',  // Event handler for button click
                    },
            
                    onButtonClick: function() {
                        alert('Button Clicked!');  // Displaying an alert when button is clicked
                    },
                });
            
                return CustomButtonWidget;  // Returning the widget for use in other parts of the app
            });
                    </code></pre>

    <p><strong>Explanation:</strong></p>
    <ul>
      <li><strong>odoo.define:</strong> Isse hum ek custom module define karte hain, jisme widget ka code hota hai.</li>
      <li><strong>AbstractAction:</strong> Ye base class hai jo custom actions aur widgets ko define karne ke liye use
        hoti hai.</li>
      <li><strong>template:</strong> Ye widget ka QWeb template hai jo button ko render karega.</li>
      <li><strong>events:</strong> Ye wo events hain jo widget pe occur hoti hain, jaise button click. Jab button click
        hota hai, <code>onButtonClick</code> method trigger hota hai.</li>
      <li><strong>onButtonClick:</strong> Ye method button click hone par ek alert show karta hai.</li>
    </ul>

    <div class="subsection-title">QWeb Template (XML) for the button:</div>
    <pre><code class="language-xml">
            &lt;odoo&gt; 
                &lt;!-- This template will render the button for the CustomButtonWidget --&gt; 
                &lt;template id="my_module.CustomButtonWidgetTemplate"&gt; 
                    &lt;div class="custom_button_container"&gt; 
                        &lt;button type="button" class="my_button"&gt; Click Me&lt;/button&gt; 
                    &lt;/div&gt; 
                &lt;/template&gt; 
            &lt;/odoo&gt;
                    </code></pre>

    <p>Is template mein ek button define kiya gaya hai. Jab user is button ko click karega, JavaScript code me defined
      <code>onButtonClick</code> method call hoga aur ek alert show karega.
    </p>

    <div class="section-title">3. How Views, Actions, and Components Interact in the Odoo Frontend</div>
    <p>Odoo mein views, actions, aur components ka ek strong interaction hota hai. Jab user koi action perform karta
      hai, jaise ek button click karna ya record open karna, to Odoo ka frontend yeh sab cheezein handle karta hai.</p>

    <div class="subsection-title">Views</div>
    <p>Views woh elements hain jo user ko data display karne ka method define karte hain. Odoo mein kuch common types of
      views hote hain:</p>

    <ul>
      <li><strong>Form View:</strong> Ye ek record ke details dikhata hai, jaise employee ka profile.</li>
      <li><strong>List View:</strong> Ye ek list of records dikhata hai, jaise employee list.</li>
      <li><strong>Kanban View:</strong> Ye visual task management ko show karta hai.</li>
    </ul>

    <div class="subsection-title">Example of a Form View (XML)</div>
    <pre><code class="language-xml">
            &lt;odoo&gt; 
                &lt;record id="view_employee_form" model="ir.ui.view"&gt; 
                    &lt;field name="name"&gt; Employee Form&lt;/field&gt; 
                    &lt;field name="model"&gt; hr.employee&lt;/field&gt; 
                    &lt;field name="arch" type="xml"&gt; 
                        &lt;form&gt; 
                            &lt;sheet&gt; 
                                &lt;group&gt; 
                                    &lt;field name="name"/&gt;   &lt;!-- Employee Name --&gt; 
                                    &lt;field name="job_id"/&gt;   &lt;!-- Employee Job ID --&gt; 
                                    &lt;field name="department_id"/&gt;   &lt;!-- Employee Department --&gt; 
                                &lt;/group&gt; 
                            &lt;/sheet&gt; 
                        &lt;/form&gt; 
                    &lt;/field&gt; 
                &lt;/record&gt; 
            &lt;/odoo&gt;
                    </code></pre>
  </div>










  <div class="content">
    <!-- Explanation about the XML tags used in Odoo to define records and fields -->
    <p><span class="important">&lt;record&gt;</span>: Isse hum ek form view define kar rahe hain jo employee details
      dikhayega.</p>
    <p><span class="important">&lt;field&gt;</span>: Ye fields ko dikhata hai, jaise employee ka name, job ID, aur
      department.</p>

    <!-- Introduction to Actions in Odoo -->
    <h3 class="section-title">Actions</h3>
    <p>Actions woh operations hain jo views ko trigger karte hain. Agar user koi specific task perform karta hai, to ek
      action call hota hai.</p>

    <!-- Example of defining an action to open Employee List -->
    <h4 class="subsection-title">Example of an Action to Open Employee List:</h4>
    <pre class="language-xml"><code>
              &lt;odoo&gt; 
                  &lt;record id="action_employee_list" model="ir.actions.act_window"&gt; 
                      &lt;field name="name"&gt; Employee List&lt;/field&gt; 
                      &lt;field name="res_model"&gt; hr.employee&lt;/field&gt; 
                      &lt;field name="view_mode"&gt; tree,form&lt;/field&gt;   &lt;!-- First List view (tree), then Form view --&gt; 
                  &lt;/record&gt; 
              &lt;/odoo&gt; 
                      </code></pre>

    <p><span class="important">&lt;record&gt;</span>: Ye action ko define karta hai, jo user ko hr.employee model ke
      liye list view aur form view ko display karta hai.</p>
    <p><span class="important">view_mode</span>: Ye specify karta hai ki pehle list view (tree), aur fir form view
      render hoga.</p>

    <!-- Introduction to Components in Odoo -->
    <h3 class="section-title">Components</h3>
    <p>Components are the building blocks of Odoo’s frontend architecture. They are used to create complex interfaces
      and handle user interactions within views.</p>

    <!-- Conclusion section -->
    <h3 class="section-title">Conclusion</h3>
    <p>Odoo ka web client ek dynamic aur modular structure provide karta hai jo views, actions, aur widgets ko combine
      karta hai. Ye interaction ka ek seamless experience deta hai jisme:</p>
    <ul>
      <li><span class="important">Views</span>: User ko data dikhane ke liye layouts define karte hain.</li>
      <li><span class="important">Actions</span>: User interactions ko handle karte hain aur unke basis par relevant
        views ko open karte hain.</li>
      <li><span class="important">Widgets</span>: Interactive elements hote hain jo user ke actions ko process karte
        hain.</li>
    </ul>

    <!-- Section introducing Odoo Widgets -->
    <h3 class="section-title">Odoo Mein Widgets Kya Hote Hain?</h3>
    <p>Widget ek UI component hota hai jo kisi specific element ya behavior ko handle karta hai, jaise button, input
      field, date picker, etc. Ye elements user interactions ko manage karte hain aur frontend ko dynamically update
      karte hain.</p>

    <!-- Features of Odoo Widgets -->
    <h4 class="subsection-title">Odoo Widgets Ke Features:</h4>
    <ul>
      <li><span class="important">Encapsulation</span>: Har widget apne behavior aur state ko manage karta hai, jo usse
        modular aur reusable banaata hai.</li>
      <li><span class="important">Modularity</span>: Ek widget ko multiple jagah use kiya ja sakta hai bina major
        changes ke.</li>
      <li><span class="important">Interactivity</span>: Widgets ka kaam hai user ke actions ko handle karna (button
        clicks, form inputs, etc.) aur uss hisaab se UI ko update karna.</li>
    </ul>

    <!-- Types of Widgets in Odoo -->
    <h4 class="subsection-title">Odoo Mein Types of Widgets:</h4>
    <ul>
      <li><span class="important">Input Widgets</span>: Ye user se data lene ke liye hote hain, jaise text input,
        checkbox, etc.</li>
      <li><span class="important">Button Widgets</span>: Ye actions trigger karte hain, jaise form submit karna ya kisi
        action ko execute karna.</li>
      <li><span class="important">Field Widgets</span>: Ye fields ko represent karte hain, jaise date picker, selection
        fields, etc.</li>
    </ul>

    <!-- Explanation of using Owl components to create custom widgets -->
    <h3 class="section-title">Odoo Widget System Ke Saath Kaam Karna Aur Owl Components Se Unka Relation</h3>
    <p>Odoo mein widgets ko banane ke liye Owl (Odoo Web Library) ka use hota hai, jo ek modern JavaScript framework
      hai. Owl ko Odoo frontend mein UI components aur widgets banane ke liye use kiya jata hai.</p>

    <h4 class="subsection-title">Owl Aur Widgets Ke Beech Relation:</h4>
    <ul>
      <li><span class="important">Owl Components</span>: Owl ek reactive framework hai jisme aap reusable components
        banate ho jo data change hone par UI ko update karte hain.</li>
      <li><span class="important">Widgets</span>: Odoo mein widgets ko Owl components ke through banaya jata hai. Ye
        components manage karte hain user interactions ko aur dynamically render karte hain views ko.</li>
      <li><span class="important">State-driven</span>: Owl ka use widgets ko more modular, efficient aur state-driven
        banane ke liye hota hai.</li>
    </ul>

    <!-- Example of a Basic Owl Component in Odoo -->
    <h4 class="subsection-title">Example: Basic Owl Component in Odoo</h4>
    <p>Yeh ek basic example hai, jisme hum ek Owl component (widget) bana rahe hain jo ek counter increment karega jab
      user button click karega:</p>
    <pre class="language-javascript"><code>
              odoo.define('my_module.MyCustomWidget', function (require) {
                  const { Component } = require('owl');  // Owl ka base class Component
                  const { useState } = require('owl.hooks');  // State management ke liye useState hook
              
                  class MyCustomWidget extends Component {
                      constructor() {
                          super(...arguments);
                          this.state = useState({ count: 0 });  // Initial state define karte hain (count = 0)
                      }
              
                      // Increment method jo counter ko increase karega
                      increment() {
                          this.state.count += 1;
                      }
                  }
              
                  MyCustomWidget.template = 'my_module.MyCustomWidgetTemplate';  // Template link karna
              
                  return MyCustomWidget;
              });
                      </code></pre>

    <p><span class="important">Component</span>: Yeh base class hai jo humne apne custom widget banane ke liye extend
      kiya.</p>
    <p><span class="important">useState</span>: Yeh ek hook hai jo widget ke state ko manage karta hai (jaise humne
      count state define kiya).</p>
    <p><span class="important">increment()</span>: Yeh method hai jo button click hone par counter ko increment karega.
    </p>
    <p><span class="important">template</span>: Yeh template ko link karta hai jo widget ka structure define karega.</p>

    <!-- Creating Custom Widgets and Linking Them to Views -->
    <h3 class="section-title">Custom Widgets Banana Aur Views Ke Saath Unhe Link Karna</h3>
    <p>Agar aapko apna custom widget banana hai aur views ke saath link karna hai, to aapko Owl ka use karna hoga. Aap
      apne widget ko create karenge aur fir usse ek view mein integrate karenge.</p>

    <!-- Example of a Custom Button Widget -->
    <h4 class="subsection-title">Example: Custom Button Widget Banane Ka Step-by-Step Process</h4>
    <p>Maan lijiye hum ek custom button widget create kar rahe hain, jo counter ko increment karega jab user button pe
      click karega.</p>

    <h5 class="subsection-title">1. Owl Component (Widget) Banaana</h5>
    <pre class="language-javascript"><code>
              odoo.define('my_module.MyCounterButton', function (require) {
                  const { Component } = require('owl');  // Owl ka base component
                  const { useState } = require('owl.hooks');  // State management ke liye useState hook
              
                  class MyCounterButton extends Component {
                      constructor() {
                          super(...arguments);
                          this.state = useState({ counter: 0 });  // Counter ka state define karna
                      }
              
                      // Button click hone par counter ko increment karna
                      increment() {
                          this.state.counter += 1;
                      }
                  }
              
                  MyCounterButton.template = 'my_module.MyCounterButtonTemplate';  // Template link karna
              
                  return MyCounterButton;
              }); 
                      </code></pre>
  </div>



  <div class="content">

    <!-- Section Title for the main topic -->
    <h1 class="section-title">2. HTML Template Banaana</h1>

    <!-- Explanation of the HTML Template -->
    <p>
      <strong>XML:</strong>
      <code>&lt;odoo&gt; &lt;template id="my_module.MyCounterButtonTemplate"&gt;</code>
      <br>
      &lt;div class="my_counter_button"&gt;
      <br>
      &lt;button t-on-click="increment"&gt; Increment Counter&lt;/button&gt;
      <!-- Button click event -->
      <br>
      &lt;p&gt; Counter: &lt;span t-esc="state.counter"/&gt; &lt;/p&gt;
      <!-- Counter ki value display karna -->
      <br>
      &lt;/div&gt;
      <br>
      &lt;/template&gt;
      <br>
      &lt;/odoo&gt;
    </p>

    <!-- Explanation of the code in the template -->
    <p><strong>Explanation:</strong></p>
    <ul>
      <li><span class="important">MyCounterButton:</span> Yeh component (widget) ek counter display karega aur button pe
        click hone par increment karega.</li>
      <li><span class="important">t-on-click="increment":</span> Jab user button pe click karega,
        <code>increment()</code> method trigger hoga.
      </li>
      <li><span class="important">t-esc="state.counter":</span> Yeh template ka syntax hai jo counter ki value ko
        display karta hai.</li>
    </ul>

    <!-- Section Title for the next topic -->
    <h2 class="subsection-title">3. View Mein Widget Ko Use Karna</h2>

    <!-- Explanation for integrating the widget in the Odoo view -->
    <p>
      Jab hum widget bana lete hain, tab usse Odoo ke view mein integrate karna hota hai. For example, hum apne custom
      button widget ko ek form view mein use karenge.
    </p>

    <!-- Example code for integrating the widget -->
    <p>
      <strong>XML:</strong>
      <code>&lt;odoo&gt;</code>
      <br>
      &lt;record id="view_custom_button_form" model="ir.ui.view"&gt;
      <br>
      &lt;field name="name"&gt; Custom Button Form&lt;/field&gt;
      <br>
      &lt;field name="model"&gt; my.model&lt;/field&gt;
      <br>
      &lt;field name="arch" type="xml"&gt;
      <br>
      &lt;form&gt;
      <br>
      &lt;group&gt;
      <br>
      &lt;widget name="MyCounterButton"/&gt; <!-- Custom Widget ko view mein include karna -->
      <br>
      &lt;/group&gt;
      <br>
      &lt;/form&gt;
      <br>
      &lt;/field&gt;
      <br>
      &lt;/record&gt;
      <br>
      &lt;/odoo&gt;
    </p>

    <!-- Explanation for the above code -->
    <p><strong>Explanation:</strong></p>
    <ul>
      <li><code>&lt;widget name="MyCounterButton"/&gt;</code>: Yeh line apne custom widget ko form view mein display kar
        rahi hai.</li>
      <li><code>model="my.model"</code>: Yeh view kis model ke liye hai, wo define karta hai.</li>
    </ul>

    <!-- Section Title for the next topic -->
    <h2 class="subsection-title">Odoo Backend ke Saath Integration: Owl Aur Odoo Models, Controllers Aur Actions</h2>

    <!-- Overview of integrating Odoo frontend with backend -->
    <p>
      Odoo ka web client front-end ko dynamic aur interactive banane ke liye Owl framework ka use karta hai. Ye
      framework user interactions ko efficiently handle karta hai. Par agar hum frontend ko backend ke saath integrate
      karte hain, to Odoo models, controllers, aur RPC (Remote Procedure Call) ka use karna padta hai.
    </p>

    <p>
      Yeh integration humari web application ko backend ke data ke saath interact karne, submit karne, aur fetch karne
      mein madad karta hai.
    </p>

    <!-- Explanation of Odoo’s interaction with backend models and controllers -->
    <p><strong>Aaj hum samjhenge:</strong></p>
    <ul>
      <li>Owl ka Odoo Backend ke Models aur Controllers ke saath kaise interaction hota hai?</li>
      <li>Odoo ke RPC ka use kaise karte hain data fetch karne aur submit karne ke liye?</li>
      <li>Odoo ke Action System aur Views ka backend se kaise use karte hain (jaise buttons, actions)?</li>
    </ul>

    <!-- Section Title for Owl Backend Interaction -->
    <h2 class="subsection-title">1. Owl Ka Odoo Backend Models Aur Controllers Ke Saath Interaction</h2>

    <!-- Explanation of how Owl interacts with Odoo backend -->
    <p>
      Odoo ka backend Python mein likha hota hai, jisme models (data structure) aur controllers (business logic) hote
      hain. Frontend (Owl) ko backend se interact karne ke liye RPC (Remote Procedure Call) ka use kiya jata hai. Iska
      matlab hai ki Owl components backend se data fetch karne ya submit karne ke liye API calls karte hain.
    </p>

    <p>
      <strong>Models Aur Controllers:</strong>
      <br>
      <strong>Models:</strong> Ye Odoo mein data ko represent karte hain. Jaise <code>hr.employee</code>,
      <code>product.product</code> etc.
      <br>
      <strong>Controllers:</strong> Ye request aur response ko handle karte hain, jo frontend se backend tak jata hai.
      Controllers API endpoints define karte hain jo frontend ko data provide karte hain.
    </p>

    <!-- Example of Owl component interacting with Odoo Backend Model -->
    <h3 class="subsection-title">Example: Owl Component se Backend Model Ko Access Karna</h3>
    <p><strong>JavaScript:</strong></p>
    <pre class="highlight"><code class="language-javascript">
                odoo.define('my_module.MyModelWidget', function (require) {
                    const { Component } = require('owl');
                    const rpc = require('web.rpc');  // Odoo RPC import karna
                
                    class MyModelWidget extends Component {
                        constructor() {
                            super(...arguments);
                            this.state = { records: [] };
                            this.fetchData();  // Data fetch karte hain on initialization
                        }
                
                        // Function to fetch data from backend
                        fetchData() {
                            rpc.query({
                                model: 'hr.employee',  // Model ka naam
                                method: 'search_read',  // Method jo data fetch karega
                                args: [[], ['name', 'job_title']],  // Filter aur fields jo retrieve karni hain
                            }).then((data) =>  {
                                this.state.records = data;  // Backend se data milne par update state
                            }).catch((error) =>  {
                                console.error("Error fetching data", error);
                            });
                        }
                    }
                
                    MyModelWidget.template = 'my_module.MyModelWidgetTemplate';  // Template link karna
                
                    return MyModelWidget;
                });
                        </code></pre>

  </div> <!-- End of content -->












  <div class="content">
    <h2 class="section-title">Explanation:</h2>

    <div class="highlight">
      <pre><code class="language-xml">
                              rpc.query: Yeh method Odoo ke backend se data fetch karta hai. Humne hr.employee model ko query kiya hai aur search_read method ko use karke employee ka name aur job title fetch kiya.
                              args: [[], ['name', 'job_title']]: Yeh argument define karta hai ki humne filter ke liye empty list pass kiya (sab records chahiye) aur fields ke liye name aur job_title.
                              Is tarah se, Owl component ko backend ke data ke saath interact karne ke liye RPC ka use hota hai.
                          </code></pre>
    </div>

    <h3 class="subsection-title">2. Odoo ke RPC Ka Use Karna: Data Fetch Aur Submit Karna</h3>

    <p>
      Odoo mein RPC (Remote Procedure Call) ek method hai jo frontend (Owl components) ko backend models ke methods ko
      call karne mein madad karta hai. Iska use karke aap data fetch kar sakte hain, data update kar sakte hain ya new
      records create kar sakte hain.
    </p>

    <h4 class="subsection-title">RPC ka Use for Data Fetching:</h4>
    <div class="highlight">
      <pre><code class="language-javascript">
                              rpc.query({
                                  model: 'hr.employee',
                                  method: 'search_read',
                                  args: [[], ['name', 'job_title']],
                              }).then((data) =&gt;  {
                                  console.log('Employee Data:', data);  // Data ko frontend mein use karte hain
                              }).catch((error) =&gt;  {
                                  console.error('Error:', error);
                              });
                          </code></pre>
    </div>

    <h4 class="subsection-title">RPC ka Use for Data Submission:</h4>
    <div class="highlight">
      <pre><code class="language-javascript">
                              rpc.query({
                                  model: 'hr.employee',
                                  method: 'create',
                                  args: [{
                                      'name': 'John Doe',
                                      'job_title': 'Developer',
                                  }],
                              }).then((result) =&gt;  {
                                  console.log('Employee Created:', result);  // Naya employee create hone par result
                              }).catch((error) =&gt;  {
                                  console.error('Error:', error);
                              });
                          </code></pre>
    </div>

    <p>
      <strong>Explanation:</strong><br>
      method: 'create': Yeh backend model ka method hai jo new record create karega.<br>
      args: [{'name': 'John Doe', 'job_title': 'Developer'}]: Yeh arguments hain jo method ko pass kiye ja rahe hain
      (employee ka name aur job title).
    </p>

    <h3 class="subsection-title">3. Odoo ke Action System Aur Views Ka Backend Se Kaise Use Karte Hain</h3>

    <p>
      Odoo mein actions ka concept hota hai jisse aap views ko open kar sakte hain, records ko perform kar sakte hain ya
      custom actions ko trigger kar sakte hain. Backend se action ko trigger karna aur usse view ko render karna bhi
      important hota hai.
    </p>

    <h4 class="subsection-title">Odoo Actions:</h4>
    <ul>
      <li><strong>Window Actions:</strong> Ye views ko render karte hain, jaise list view ya form view.</li>
      <li><strong>Server Actions:</strong> Ye backend tasks ko perform karte hain, jaise sending emails ya running
        custom Python functions.</li>
      <li><strong>Client Actions:</strong> Ye client-side tasks ko handle karte hain, jaise UI ko update karna ya custom
        widgets ko render karna.</li>
    </ul>

    <h4 class="subsection-title">Example: Backend se Action Trigger Karna (Server Action)</h4>

    <div class="highlight">
      <pre><code class="language-python">
                              from odoo import models, fields, api
                  
                              class HrEmployee(models.Model):
                                  _name = 'hr.employee'
                                  
                                  name = fields.Char('Employee Name')
                                  
                                  @api.model
                                  def perform_custom_action(self):
                                      # Custom action to perform when triggered from the frontend
                                      employees = self.search([('job_title', '=', 'Developer')])
                                      for employee in employees:
                                          employee.write({'job_title': 'Senior Developer'})
                          </code></pre>
    </div>

    <h4 class="subsection-title">Frontend se Action Call Karna (Owl component mein)</h4>
    <div class="highlight">
      <pre><code class="language-javascript">
                              odoo.define('my_module.MyCustomActionButton', function (require) {
                                  const { Component } = require('owl');
                                  const rpc = require('web.rpc');
                  
                                  class MyCustomActionButton extends Component {
                                      callAction() {
                                          rpc.query({
                                              model: 'hr.employee',
                                              method: 'perform_custom_action',
                                              args: [],
                                          }).then(() =&gt;  {
                                              alert("Action Completed!");
                                          }).catch((error) =&gt;  {
                                              console.error("Error:", error);
                                          });
                                      }
                                  }
                  
                                  MyCustomActionButton.template = 'my_module.MyCustomActionButtonTemplate';
                                  return MyCustomActionButton;
                              });
                          </code></pre>
    </div>

    <p><strong>Explanation:</strong><br>
      Backend (Python): Humne ek custom method perform_custom_action create kiya hai, jo employees ke job_title ko
      change karega.<br>
      Frontend (Owl): Humne rpc.query use kiya hai backend action ko call karne ke liye.
    </p>

    <h3 class="section-title">Advanced Odoo JS Features</h3>
    <p>
      Odoo ka web client JavaScript (JS) ko extensive use karta hai, aur isme kai advanced JS features bhi hote hain jo
      web applications ko highly interactive aur dynamic banate hain. In features ka use karke aap complex
      functionalities ko implement kar sakte hain, jaise custom widgets, dynamic views, event handling, and performance
      optimizations.
    </p>

    <h4 class="subsection-title">1. Owl Framework ke Advanced Features</h4>
    <p>
      Owl Odoo ka reactive JavaScript framework hai, jo UI components ko efficiently render aur manage karta hai. Owl
      mein kuch advanced features hain jo aapko complex interactions aur dynamic behavior implement karne mein madad
      karte hain.
    </p>

    <h5 class="subsection-title">1.1. Reactive State Management</h5>
    <p>
      Owl ka reactive state management mechanism highly efficient hai. Jab component ki state change hoti hai, to Owl
      automatic UI ko re-render karta hai. Isse UI ka state always synchronized rehta hai.
    </p>

    <div class="highlight">
      <pre><code class="language-javascript">
                              odoo.define('my_module.MyCounterWidget', function (require) {
                                  const { Component } = require('owl');
                                  const { useState } = require('owl.hooks');
                  
                                  class MyCounterWidget extends Component {
                                      constructor() {
                                          super(...arguments);
                                          this.state = useState({ count: 0 }); // state ko initialize karte hain
                                      }
                  
                                      increment() {
                                          this.state.count += 1; // state update karte hain
                                      }
                                  }
                  
                                  MyCounterWidget.template = 'my_module.MyCounterWidgetTemplate';
                  
                                  return MyCounterWidget;
                              });
                          </code></pre>
    </div>

    <h5 class="subsection-title">1.2. Owl Event Handling</h5>
    <p>
      Owl mein event handling bhi advanced level tak customizable hota hai. Aap kisi bhi event ko handle kar sakte hain
      jaise click, change, focus, etc.
    </p>

    <div class="highlight">
      <pre><code class="language-javascript">
                              odoo.define('my_module.MyButtonWidget', function (require) {
                                  const { Component } = require('owl');
                                  
                                  class MyButtonWidget extends Component {
                                      handleClick(event) {
                                          console.log('Button clicked', event);
                                      }
                                  }
                  
                                  MyButtonWidget.template = 'my_module.MyButtonWidgetTemplate';
                  
                                  return MyButtonWidget;
                              });
                          </code></pre>
    </div>

    <h5 class="subsection-title">Template for Button</h5>
    <div class="highlight">
      <pre><code class="language-xml">
                              &lt;template id="my_module.MyButtonWidgetTemplate"&gt;
                                  &lt;button t-on-click="handleClick"&gt; Click Me!&lt;/button&gt;   &lt;!-- Handle click event --&gt;
                              &lt;/template&gt;
                          </code></pre>
    </div>
  </div>



  <div class="content">
    <h2 class="section-title">Explanation:</h2>
    <p><strong>t-on-click="handleClick"</strong>: Ye button pe click hone par <code>handleClick</code> function ko
      trigger karega, jisme aap event handle kar sakte hain.</p>

    <h3 class="subsection-title">2. Asynchronous Programming: Promises & async/await</h3>
    <p>Odoo mein kai baar aapko asynchronous programming ka use karna padta hai, jaise data ko fetch karte waqt backend
      se. Iske liye Promises aur async/await ka use kiya jata hai.</p>

    <h4 class="subsection-title">2.1. Using Promises</h4>
    <p>Promises ka use tab hota hai jab koi asynchronous task complete hone ke baad koi action perform karna ho.</p>

    <pre><code class="language-javascript">
                    rpc.query({
                        model: 'hr.employee',
                        method: 'search_read',
                        args: [[], ['name', 'job_title']],
                    }).then((data) =>  {
                        console.log(data); // Data successfully fetch hone par process karte hain
                    }).catch((error) =>  {
                        console.error('Error fetching data', error); // Error handle karte hain
                    });
                    </code></pre>

    <h4 class="subsection-title">2.2. Using async/await</h4>
    <p><code>async/await</code> ka use code ko synchronous tarike se likhne ke liye kiya jata hai, jisse readability
      improve hoti hai aur code easy to manage ho jata hai.</p>

    <pre><code class="language-javascript">
                    async function fetchEmployeeData() {
                        try {
                            const data = await rpc.query({
                                model: 'hr.employee',
                                method: 'search_read',
                                args: [[], ['name', 'job_title']],
                            });
                            console.log(data); // Data ko handle karna
                        } catch (error) {
                            console.error('Error:', error); // Error handle karna
                        }
                    }
                    </code></pre>

    <h3 class="subsection-title">3. Dynamic Views and Widgets</h3>
    <p>Odoo mein dynamic views aur widgets ka concept use karke hum UI ko dynamically customize kar sakte hain. Aapko
      kabhi kabhi aise widgets create karne padte hain jo kisi condition par depend karte hain.</p>

    <h4 class="subsection-title">3.1. Conditional Rendering in Views</h4>
    <p>Owl mein aap conditionals aur loops ka use kar sakte hain views ko dynamically render karne ke liye.</p>

    <pre><code class="language-javascript">
                    odoo.define('my_module.MyConditionalWidget', function (require) {
                        const { Component } = require('owl');
            
                        class MyConditionalWidget extends Component {
                            constructor() {
                                super(...arguments);
                                this.state = { showButton: false }; // Initially button nahi dikhana hai
                            }
            
                            toggleButton() {
                                this.state.showButton = !this.state.showButton; // Button ko toggle karna
                            }
                        }
            
                        MyConditionalWidget.template = 'my_module.MyConditionalWidgetTemplate';
            
                        return MyConditionalWidget;
                    });
                    </code></pre>

    <pre><code class="language-xml">
                    &lt;template id="my_module.MyConditionalWidgetTemplate"&gt; 
                        &lt;button t-if="state.showButton" t-on-click="toggleButton"&gt; Click Me!&lt;/button&gt;   &lt;!-- Button conditionally show ho raha hai --&gt; 
                    &lt;/template&gt; 
                    </code></pre>
    <p><strong>t-if="state.showButton"</strong>: Yeh condition check karta hai ki button ko show karna hai ya nahi. Agar
      showButton true hai, to button dikhega, varna nahi.</p>

    <h3 class="subsection-title">4. Performance Optimization Techniques in Odoo JS</h3>
    <p>Jab Odoo ka web client complex applications ko handle karta hai, to performance kaafi important ho jata hai. Odoo
      mein aap virtual DOM, lazy loading, aur caching techniques ka use kar ke performance improve kar sakte hain.</p>

    <h4 class="subsection-title">4.1. Virtual DOM and Optimization</h4>
    <p>Owl mein virtual DOM ka concept hota hai, jisme unnecessary DOM updates ko minimize kiya jata hai. Agar data
      change hota hai to sirf wo parts re-render hote hain jo actually change hue hain.</p>

    <h4 class="subsection-title">4.2. Lazy Loading</h4>
    <p>Lazy loading ka matlab hai ki views ya components tabhi load honge jab user unhe dekhega. Isse initial load time
      bahut kam hota hai aur application faster feel hoti hai.</p>

    <pre><code class="language-javascript">
                    odoo.define('my_module.MyLazyLoadWidget', function (require) {
                        const { Component } = require('owl');
                        const rpc = require('web.rpc');
                        
                        class MyLazyLoadWidget extends Component {
                            constructor() {
                                super(...arguments);
                                this.state = { records: [] };
                            }
            
                            // Lazy load data when required
                            loadData() {
                                if (this.state.records.length === 0) {
                                    rpc.query({
                                        model: 'hr.employee',
                                        method: 'search_read',
                                        args: [[], ['name']],
                                    }).then((data) =>  {
                                        this.state.records = data;
                                    });
                                }
                            }
                        }
            
                        MyLazyLoadWidget.template = 'my_module.MyLazyLoadWidgetTemplate';
            
                        return MyLazyLoadWidget;
                    });
                    </code></pre>
    <p><strong>Lazy Loading</strong>: Data tab load hota hai jab user us widget ko interact karta hai, jisse initial
      load fast hota hai.</p>

    <h2 class="section-title">Building and Customizing Dashboards in Odoo</h2>
    <p>Odoo mein dashboards create karna ek powerful feature hai jo aapko business metrics aur KPIs (Key Performance
      Indicators) ko visually represent karne mein madad karta hai. Dashboards typically charts, graphs, tables aur data
      visualizations ko combine karte hain, taaki users ko data easily samajh aaye.</p>

    <p>Owl Framework ka use karke aap custom dashboards bana sakte hain, jisme aap charts aur graphs ko integrate kar
      sakte hain. Odoo ka QWeb template engine aur Owl components ko combine karke aap complex dashboard features ko
      design kar sakte hain.</p>

    <h3 class="subsection-title">1. Using Owl to Build Custom Dashboards in Odoo</h3>
    <p>Owl ka use Odoo mein highly interactive aur dynamic UI components banane ke liye kiya jata hai. Custom dashboards
      banate waqt hum Owl components ka use karte hain jisme state management, event handling, aur reactivity ko handle
      kiya jata hai.</p>

    <h4 class="subsection-title">1.1. Basic Setup for Dashboard in Odoo</h4>
    <p>Custom dashboard create karne ke liye pehle ek component define karte hain jisme hum data ko display karne ke
      liye charts aur other visual elements use karenge. Hum state management ko handle karte hain taaki dashboard
      dynamic ho aur real-time data ko reflect kare.</p>

    <pre><code class="language-javascript">
                    odoo.define('my_module.MyDashboard', function (require) {
                        const { Component } = require('owl');
                        const { useState, useRef } = require('owl.hooks');
                        const rpc = require('web.rpc'); // RPC ka use data fetch karne ke liye
            
                        class MyDashboard extends Component {
                            constructor() {
                                super(...arguments);
                                this.state = useState({
                                    salesData: [],
                                    revenueData: [],
                                });
                            }
            
                            // Data ko fetch karte hain
                            async fetchData() {
                                const salesData = await rpc.query({
                                    model: 'sale.order',
                                    method: 'read',
                                    args: [[], ['amount_total']],
                                });
                                this.state.salesData = salesData;
            
                                const revenueData = await rpc.query({
                                    model: 'account.invoice',
                                    method: 'read',
                                    args: [[], ['amount_total']],
                                });
                                this.state.revenueData = revenueData;
                            }
            
                            // Component mount hone par data fetch karenge
                            mounted() {
                                this.fetchData();
                            }
                        }
            
                        MyDashboard.template = 'my_module.MyDashboardTemplate';
                        return MyDashboard;
                    });
                    </code></pre>
  </div>



  <div class="content">
    <!-- Explanation section for the functions and methods used -->
    <h2 class="section-title">Explanation:</h2>

    <div class="highlight">
      <p><strong>fetchData function:</strong> Ye function rpc.query() ka use karke sales aur revenue data ko fetch karta
        hai.</p>
      <p><strong>mounted lifecycle hook:</strong> Ye hook component ke render hone ke baad data fetch karne ke liye use
        hota hai.</p>
      <p><strong>useState:</strong> Dashboard ke data ko manage karne ke liye state ka use hota hai.</p>
    </div>

    <h2 class="section-title">1.2. Custom Dashboard Layout</h2>

    <p>Dashboard ka layout aapke design aur user requirement ke hisaab se customized ho sakta hai. Hum QWeb templates ka
      use karte hain jisme Owl components ko render kiya jata hai.</p>

    <h3 class="subsection-title">Example: Custom Dashboard Template (QWeb)</h3>

    <pre class="language-xml">
                      &lt;template id="my_module.MyDashboardTemplate"&gt; 
                          &lt;div class="my_dashboard"&gt; 
                              &lt;h2&gt; Sales and Revenue Dashboard&lt;/h2&gt; 
          
                              &lt;!-- Sales Data Section --&gt; 
                              &lt;div class="section"&gt; 
                                  &lt;h3&gt; Sales Overview&lt;/h3&gt; 
                                  &lt;t t-foreach="state.salesData" t-as="sales"&gt; 
                                      &lt;div class="sales-item"&gt; 
                                          &lt;span t-esc="sales.amount_total" /&gt; 
                                      &lt;/div&gt; 
                                  &lt;/t&gt; 
                              &lt;/div&gt; 
          
                              &lt;!-- Revenue Data Section --&gt; 
                              &lt;div class="section"&gt; 
                                  &lt;h3&gt; Revenue Overview&lt;/h3&gt; 
                                  &lt;t t-foreach="state.revenueData" t-as="revenue"&gt; 
                                      &lt;div class="revenue-item"&gt; 
                                          &lt;span t-esc="revenue.amount_total" /&gt; 
                                      &lt;/div&gt; 
                                  &lt;/t&gt; 
                              &lt;/div&gt; 
                          &lt;/div&gt; 
                      &lt;/template&gt;
                  </pre>

    <div class="highlight">
      <p><strong>t-foreach:</strong> Ye loop ke through data ko display karta hai. state.salesData aur state.revenueData
        ko dynamically render kiya gaya hai.</p>
      <p><strong>Template Structure:</strong> Hum simple HTML structure mein dashboard layout design kar rahe hain,
        jisme sales aur revenue data ko show karne ke liye div elements ka use kiya gaya hai.</p>
    </div>

    <h2 class="section-title">2. Integrating Charts, Graphs, and Data Visualizations into Odoo Views</h2>

    <p>Charts aur graphs ko Odoo views mein integrate karna bahut important hota hai, jisse data ko visually represent
      kiya ja sake. Aap JavaScript charting libraries ka use kar sakte hain, jaise Chart.js, D3.js, ya Plotly.</p>

    <h3 class="subsection-title">2.1. Using Chart.js in Odoo</h3>

    <p>Chart.js ek popular JavaScript library hai jo responsive aur interactive charts banane mein madad karti hai. Hum
      Chart.js ko Odoo mein use karke sales, revenue, aur other metrics ko visual form mein represent kar sakte hain.
    </p>

    <h3 class="subsection-title">Example: Integrating Chart.js into Odoo</h3>

    <pre class="language-javascript">
                      odoo.define('my_module.MyChartWidget', function (require) {
                          const { Component } = require('owl');
                          const { useState, useRef } = require('owl.hooks');
                          const Chart = require('chart.js'); // Chart.js ko import karte hain
          
                          class MyChartWidget extends Component {
                              constructor() {
                                  super(...arguments);
                                  this.state = useState({
                                      chartData: [12, 19, 3, 5, 2, 3], // Example chart data
                                  });
                              }
          
                              mounted() {
                                  this.renderChart();
                              }
          
                              renderChart() {
                                  const ctx = this.refs.chartCanvas;
                                  new Chart(ctx, {
                                      type: 'bar',
                                      data: {
                                          labels: ['Red', 'Blue', 'Yellow', 'Green', 'Purple', 'Orange'],
                                          datasets: [{
                                              label: 'My First Dataset',
                                              data: this.state.chartData,
                                          }]
                                      }
                                  });
                              }
                          }
          
                          MyChartWidget.template = 'my_module.MyChartWidgetTemplate';
                          return MyChartWidget;
                      });
                  </pre>

    <pre class="language-xml">
                      &lt;template id="my_module.MyChartWidgetTemplate"&gt; 
                          &lt;div class="my_chart_widget"&gt; 
                              &lt;canvas t-ref="chartCanvas"&gt; &lt;/canvas&gt;   &lt;!-- Chart.js canvas element --&gt; 
                          &lt;/div&gt; 
                      &lt;/template&gt; 
                  </pre>

    <div class="highlight">
      <p><strong>Chart.js Integration:</strong> Humne Chart.js ko import kiya hai aur renderChart function mein chart ko
        render karte hain.</p>
      <p><strong>t-ref:</strong> Ye directive chartCanvas element ko reference karta hai, jahan pe hum chart render
        karte hain.</p>
    </div>

    <h2 class="section-title">2.2. Adding Data Interactivity to Charts</h2>

    <p>Charts ko dynamic aur interactive banane ke liye aap users ke inputs ko handle kar sakte hain. Jaise, users ko
      chart pe click karne par detailed view ya specific data show karna.</p>

    <h3 class="subsection-title">Example: Interactive Chart with Click Event</h3>

    <pre class="language-javascript">
                      odoo.define('my_module.InteractiveChartWidget', function (require) {
                          const { Component } = require('owl');
                          const { useState } = require('owl.hooks');
                          const Chart = require('chart.js');
          
                          class InteractiveChartWidget extends Component {
                              constructor() {
                                  super(...arguments);
                                  this.state = useState({
                                      chartData: [10, 20, 30, 40, 50, 60],
                                  });
                              }
          
                              mounted() {
                                  this.renderChart();
                              }
          
                              renderChart() {
                                  const ctx = this.refs.chartCanvas;
                                  this.myChart = new Chart(ctx, {
                                      type: 'line',
                                      data: {
                                          labels: ['January', 'February', 'March', 'April', 'May', 'June'],
                                          datasets: [{
                                              label: 'Revenue Data',
                                              data: this.state.chartData,
                                          }]
                                      },
                                      options: {
                                          onClick: (e) =&gt;  this.onChartClick(e),
                                      }
                                  });
                              }
          
                              onChartClick(e) {
                                  const activePoint = this.myChart.getElementAtEvent(e);
                                  if (activePoint.length &gt;  0) {
                                      const index = activePoint[0]._index;
                                      console.log('Clicked on month:', this.myChart.data.labels[index]);
                                  }
                              }
                          }
          
                          InteractiveChartWidget.template = 'my_module.InteractiveChartWidgetTemplate';
                          return InteractiveChartWidget;
                      });
                  </pre>

    <pre class="language-xml">
                      &lt;template id="my_module.InteractiveChartWidgetTemplate"&gt; 
                          &lt;div class="interactive_chart_widget"&gt; 
                              &lt;canvas t-ref="chartCanvas"&gt; &lt;/canvas&gt;   &lt;!-- Interactive chart canvas --&gt; 
                          &lt;/div&gt; 
                      &lt;/template&gt; 
                  </pre>
  </div>





  <div class="content">
    <h2 class="section-title">Internationalization and Localization in Odoo</h2>
    <p>
      Odoo mein Internationalization (i18n) aur Localization (l10n) ka use karke aap apne web application ko different
      languages mein translate kar sakte hain aur usse specific regions ke liye customize kar sakte hain. Yeh feature
      Odoo ko global level pe accessible banata hai.
    </p>
    <p>
      Odoo frontend views mein multi-language support provide karna, Owl components ko translate karna, aur localization
      ko handle karna essential hote hain jab aap apne application ko diverse users ke liye accessible banana chahte
      hain.
    </p>
    <p>
      Is section mein, hum Internationalization aur Localization concepts ko Owl components mein kaise implement karte
      hain, usse samjhenge.
    </p>

    <h3 class="subsection-title">1. Translating Your Owl Components</h3>
    <p>
      Odoo mein translation system ek integrated tool hai jo Odoo’s QWeb templates aur JavaScript components ke liye
      translations ko manage karta hai. Owl components ko bhi Odoo ke translation framework ke saath integrate kiya ja
      sakta hai, taaki aap apne components ko multiple languages mein translate kar sakein.
    </p>

    <h4 class="subsection-title">1.1 Translating Static Text in Owl Components</h4>
    <p>
      Odoo mein translation ke liye _.tr function use kiya jata hai, jo static text ko translate karta hai. Jab aap ek
      Owl component bana rahe hote hain, tab aapko apne static text ko translate-able banane ke liye _.tr ka use karna
      padta hai.
    </p>

    <pre><code class="language-javascript">
                    odoo.define('my_module.MyTranslatableComponent', function (require) {
                        const { Component } = require('owl');
                        const { _ } = require('web.core');  // Import translation function
            
                        class MyTranslatableComponent extends Component {
                            constructor() {
                                super(...arguments);
                            }
                        }
            
                        MyTranslatableComponent.template = 'my_module.MyTranslatableComponentTemplate';
                        return MyTranslatableComponent;
                    });
                </code></pre>

    <pre><code class="language-xml">
                    &lt;template id="my_module.MyTranslatableComponentTemplate"&gt; 
                        &lt;div&gt; 
                            &lt;!-- Translating text using _.tr --&gt; 
                            &lt;h1&gt; &lt;t t-esc=" _('Hello, World!') "&gt; &lt;/t&gt; &lt;/h1&gt; 
                        &lt;/div&gt; 
                    &lt;/template&gt; 
                </code></pre>

    <p><strong>Explanation:</strong></p>
    <ul>
      <li><strong>_ function:</strong> Ye translation function hai jo "Hello, World!" text ko current language ke
        according translate karega.</li>
      <li><strong>QWeb Translation:</strong> t-esc=" _('Hello, World!') " Odoo ke QWeb templates mein translation ko
        embed karne ka tareeka hai.</li>
    </ul>

    <h4 class="subsection-title">1.2 Using Dynamic Text for Translation in Owl Components</h4>
    <p>
      Agar aapko dynamic text ko translate karna hai, jaise ki user ke inputs ya database ke data ko translate karna, to
      aap Odoo ke QWeb templating engine ko use karke dynamic translations bhi kar sakte hain.
    </p>

    <pre><code class="language-javascript">
                    odoo.define('my_module.MyDynamicTranslatableComponent', function (require) {
                        const { Component } = require('owl');
                        const { _ } = require('web.core');
            
                        class MyDynamicTranslatableComponent extends Component {
                            constructor() {
                                super(...arguments);
                                this.state = useState({
                                    username: 'John Doe',
                                });
                            }
            
                            get greetingMessage() {
                                return _(`Hello, ${this.state.username}!`);
                            }
                        }
            
                        MyDynamicTranslatableComponent.template = 'my_module.MyDynamicTranslatableComponentTemplate';
                        return MyDynamicTranslatableComponent;
                    });
                </code></pre>

    <pre><code class="language-xml">
                    &lt;template id="my_module.MyDynamicTranslatableComponentTemplate"&gt; 
                        &lt;div&gt; 
                            &lt;!-- Using dynamic translation --&gt; 
                            &lt;h1&gt; &lt;t t-esc="greetingMessage"&gt; &lt;/t&gt; &lt;/h1&gt; 
                        &lt;/div&gt; 
                    &lt;/template&gt; 
                </code></pre>

    <p><strong>Explanation:</strong></p>
    <ul>
      <li><strong>Dynamic Translation:</strong> Yahan pe greetingMessage ko dynamically translate kiya gaya hai. Agar
        user ka naam "John Doe" ho to "Hello, John Doe!" text show hoga, aur agar language change hoti hai, to
        translation accordingly update hota hai.</li>
    </ul>

    <h3 class="subsection-title">2. Handling Multi-Language Support in Odoo Frontend Views</h3>
    <p>
      Odoo ka translation system frontend views ko support karta hai, jisme multi-language views ke liye automatic text
      conversion kiya jata hai. Aapko apne views mein language switcher ka use karna hota hai jisse users easily
      language change kar sakein.
    </p>

    <h4 class="subsection-title">2.1 Enabling Multi-Language in Odoo</h4>
    <p>
      Odoo mein multi-language support enable karne ke liye aapko Settings menu mein language install karna hota hai.
      Jab aap language install karte hain, tab Odoo automatically language translations ko handle karne lagta hai.
    </p>
    <ul>
      <li>Go to Settings → Translations → Languages.</li>
      <li>Add a new language ya existing language ko enable karein.</li>
      <li>Install aur update language packs.</li>
    </ul>

    <h4 class="subsection-title">2.2 Language Switcher Implementation in Odoo Frontend</h4>
    <p>
      Aap apne Odoo frontend views mein language switcher ka component bhi include kar sakte hain, jisse users easily
      apne desired language mein switch kar sakein.
    </p>

    <pre><code class="language-xml">
                    &lt;template id="my_module.LanguageSwitcherTemplate"&gt; 
                        &lt;div&gt; 
                            &lt;label for="language_switcher"&gt; Select Language:&lt;/label&gt; 
                            &lt;select id="language_switcher" t-on-change="onLanguageChange"&gt; 
                                &lt;option t-foreach="state.languages" t-as="language" t-att-value="language.code"&gt; 
                                    &lt;t t-esc="language.name"/&gt; 
                                &lt;/option&gt; 
                            &lt;/select&gt; 
                        &lt;/div&gt; 
                    &lt;/template&gt; 
                </code></pre>

    <pre><code class="language-javascript">
                    odoo.define('my_module.LanguageSwitcher', function (require) {
                        const { Component } = require('owl');
                        const rpc = require('web.rpc');  // RPC for language change
            
                        class LanguageSwitcher extends Component {
                            constructor() {
                                super(...arguments);
                                this.state = useState({
                                    languages: [
                                        { code: 'en', name: 'English' },
                                        { code: 'fr', name: 'French' },
                                        { code: 'es', name: 'Spanish' },
                                    ],
                                });
                            }
            
                            async onLanguageChange(event) {
                                const selectedLanguage = event.target.value;
                                // Change the language dynamically
                                await rpc.query({
                                    model: 'res.lang',
                                    method: 'write',
                                    args: [[1], { 'code': selectedLanguage }],
                                });
                                window.location.reload();  // Reload page after language change
                            }
                        }
            
                        LanguageSwitcher.template = 'my_module.LanguageSwitcherTemplate';
                        return LanguageSwitcher;
                    });
                </code></pre>

    <p><strong>Explanation:</strong></p>
    <ul>
      <li><strong>Language Switcher:</strong> LanguageSwitcher component ek dropdown show karta hai jisme available
        languages listed hoti hain.</li>
      <li><strong>Language Change Handler:</strong> onLanguageChange method ko call karke user ke selected language ko
        Odoo ke backend mein update kiya jata hai aur page ko reload karte hain taaki language reflect ho sake.</li>
    </ul>
  </div>






















  <div class="content">
    <!-- Explanation continues with more advanced integration examples -->
    <h2 class="section-title">Odoo mein Third-Party Libraries ki Integration aur Custom Views</h2>
    <p>Is section mein hum third-party libraries ko integrate karne aur unhe Odoo views mein use karne ke baare mein
      jaanenge. Ye libraries aapke application ko zyada interactive aur feature-rich bana sakti hain.</p>

    <h3 class="subsection-title">4. Google Maps ko Odoo Mein Integrate Karna</h3>
    <p>Google Maps ka use Odoo mein maps ya geolocation functionality dene ke liye kiya ja sakta hai. Hum Google Maps
      JavaScript API ko Odoo views mein integrate kar sakte hain, jaise ki customer locations dikhane ke liye.</p>

    <h4 class="subsection-title">4.1. Google Maps API Integration Example</h4>
    <p>Google Maps ko integrate karna kaafi asaan hai. Aapko bas Google Maps JavaScript API ko include karna hota hai
      aur uska map container define karna hota hai jahan map render hoga.</p>

    <!-- Google Maps API ko include karna -->
    <pre><code class="language-xml">
          &lt;template id="assets_backend" name="Google Maps API Assets" inherit_id="web.assets_backend"&gt; 
              &lt;script src="https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY"&gt;&lt;/script&gt; &lt;!-- Google Maps API ko include kar rahe hain --&gt; 
          &lt;/template&gt;
              </code></pre>

    <!-- Custom Google Map Widget -->
    <pre><code class="language-javascript">
          odoo.define('my_module.GoogleMapWidget', function (require) {
              const { Component } = require('owl'); // Owl component ko import kar rahe hain.
              const QWeb = require('web.core').qweb; // Template rendering ke liye QWeb module ko import kar rahe hain.
          
              class GoogleMapWidget extends Component {
                  constructor() {
                      super(...arguments); // Component constructor ko call kar rahe hain.
                      this.map = null; // Map instance initialize kar rahe hain.
                      this.latitude = 40.7128; // Default latitude
                      this.longitude = -74.0060; // Default longitude
                  }
          
                  mounted() {
                      this._initMap(); // Component mounted hone par map ko initialize kar rahe hain.
                  }
          
                  // Map initialize karne ki method
                  _initMap() {
                      const mapOptions = {
                          center: new google.maps.LatLng(this.latitude, this.longitude),
                          zoom: 8
                      };
                      this.map = new google.maps.Map(this.el.querySelector('#google-map'), mapOptions); // Map container mein map render ho raha hai
                  }
              }
          
              GoogleMapWidget.template = 'my_module.GoogleMapWidgetTemplate'; // Template ko link kar rahe hain.
              return GoogleMapWidget; // Widget ko return kar rahe hain.
          });
              </code></pre>

    <!-- Google Map ka template -->
    <pre><code class="language-xml">
          &lt;template id="my_module.GoogleMapWidgetTemplate"&gt; 
              &lt;div class="google-map-container"&gt; 
                  &lt;div id="google-map" style="height: 400px; width: 100%;"&gt;&lt;/div&gt; 
                  &lt;!-- Google map display hoga yahan --&gt; 
              &lt;/div&gt; 
          &lt;/template&gt; 
              </code></pre>

    <p>Is example mein humne Google Maps JavaScript API ko Odoo view mein include kiya aur ek custom widget banaya jisme
      map ko render karne ki functionality di gayi hai. Ab aap is widget ko apne Odoo forms mein use kar sakte hain
      jahan aapko map dikhana ho.</p>

    <h3 class="subsection-title">5. Custom Reports Ke Liye JavaScript Integration</h3>
    <p>Odoo mein custom reports banane ke liye aap JavaScript ka use kar sakte hain, jaise ki charts, graphs, ya kisi
      external data source se data fetch karke display karna.</p>

    <h4 class="subsection-title">5.1. Custom Report with Chart.js Example</h4>
    <p>Is example mein hum Chart.js ko use karenge Odoo mein custom report dikhane ke liye.</p>

    <!-- Chart.js ko report view mein integrate karna -->
    <pre><code class="language-xml">
          &lt;template id="assets_backend" name="Chart.js Report Assets" inherit_id="web.assets_backend"&gt; 
              &lt;script src="https://cdn.jsdelivr.net/npm/chart.js"&gt;&lt;/script&gt; &lt;!-- Chart.js ko include kar rahe hain --&gt; 
          &lt;/template&gt;
              </code></pre>

    <!-- Report ke liye custom Chart.js Widget -->
    <pre><code class="language-javascript">
          odoo.define('my_module.ChartReportWidget', function (require) {
              const { Component } = require('owl'); // Owl component ko import kar rahe hain.
              const QWeb = require('web.core').qweb; // Template rendering ke liye QWeb module ko import kar rahe hain.
          
              class ChartReportWidget extends Component {
                  constructor() {
                      super(...arguments); // Component constructor ko call kar rahe hain.
                      this.chartData = { // Chart data ko define kar rahe hain.
                          labels: ['Q1', 'Q2', 'Q3', 'Q4'],
                          datasets: [{
                              label: 'Revenue',
                              data: [12000, 15000, 18000, 25000],
                              backgroundColor: 'rgba(153, 102, 255, 0.2)', // Bar chart ke liye color
                              borderColor: 'rgba(153, 102, 255, 1)', // Border color
                              borderWidth: 1
                          }]
                      };
                  }
          
                  mounted() {
                      this._renderChart(); // Component mount hone par chart ko render kar rahe hain.
                  }
          
                  // Chart ko render karne ke liye ye method use ho raha hai.
                  _renderChart() {
                      const ctx = this.el.querySelector('canvas').getContext('2d'); // Canvas ka context le rahe hain.
                      new Chart(ctx, { // Chart.js instance create kar rahe hain.
                          type: 'bar', // Bar chart type select kiya hai.
                          data: this.chartData, // Chart data ko pass kar rahe hain.
                          options: {
                              responsive: true, // Chart ko responsive bana rahe hain.
                              scales: {
                                  y: {
                                      beginAtZero: true // Y-axis ko zero se start kar rahe hain.
                                  }
                              }
                          }
                      });
                  }
              }
          
              ChartReportWidget.template = 'my_module.ChartReportWidgetTemplate'; // Template ko link kar rahe hain.
              return ChartReportWidget; // Widget ko return kar rahe hain.
          });
              </code></pre>

    <!-- Custom Report ka template -->
    <pre><code class="language-xml">
          &lt;template id="my_module.ChartReportWidgetTemplate"&gt; 
              &lt;div class="chart-report-container"&gt; 
                  &lt;canvas&gt; &lt;/canvas&gt;  &lt;!-- Chart display hoga yahan --&gt; 
              &lt;/div&gt; 
          &lt;/template&gt; 
              </code></pre>

    <p>Is example mein humne Chart.js ko Odoo ke custom report mein integrate kiya aur ek interactive bar chart display
      kiya. Ye approach custom reporting ko Odoo mein handle karne ka ek accha tareeqa hai.</p>
  </div>



















  <!-- Content Section -->
  <div class="content">
    <h1 class="section-title">Chart.js Integration</h1>
    <p>Humne Chart.js ko apne Odoo view mein integrate kiya hai. Is example mein hum ek bar chart display kar rahe hain
      jisme sales data show kiya gaya hai.</p>
    <p><strong>Widget Rendering:</strong> mounted lifecycle hook ka use kiya gaya hai chart ko render karne ke liye jab
      component DOM mein aata hai.</p>
    <p>Ab aap apne Odoo views mein charts ko easily integrate kar sakte hain.</p>

    <h2 class="subsection-title">Best Practices in Odoo JavaScript Development (Odoo JS Code Ke Liye Best Practices)
    </h2>
    <p>Odoo ka JavaScript framework, jo ki Owl par based hai, ek powerful aur flexible system provide karta hai. Lekin,
      effective aur maintainable Odoo JavaScript code likhna ek challenge ho sakta hai agar kuch best practices follow
      na kiya jaye. Jab aap Odoo mein JavaScript development karte hain, to kuch guidelines aur practices hoti hain jo
      aapko code ko efficiently manage karne, bugs ko avoid karne, aur apne code ko future mein easily extend karne mein
      madad karte hain.</p>
    <p>Is section mein hum Odoo JS development ke best practices ko explore karenge. Hum discuss karenge ki kis tarah se
      aap apna code maintainable, readable, aur efficient bana sakte hain.</p>

    <h3 class="subsection-title">1. Modular Code Structure</h3>
    <p>Aapke code ko modular aur reusable hona chahiye. Iska matlab hai ki aap apne components, widgets, aur methods ko
      chhote aur independent modules mein organize karen.</p>
    <p><strong>Why modular structure important hai?</strong></p>
    <ul>
      <li><strong>Reusability:</strong> Agar aap code ko modular banayenge, to aap usko easily reuse kar sakte hain bina
        kisi duplication ke.</li>
      <li><strong>Maintainability:</strong> Agar code small aur well-defined modules mein hoga, to future mein koi
        changes ya fixes karna asaan ho jata hai.</li>
      <li><strong>Debugging:</strong> Chhote modules ka debug karna zyada asaan hota hai.</li>
    </ul>
    <p><strong>Example: Modular Code Structure in Odoo JavaScript</strong></p>
    <pre class="language-javascript">
        odoo.define('my_module.DateRangePicker', function (require) {
            const core = require('web.core');
            const { Component } = require('owl'); // Owl component ko import kar rahe hain.
        
            // DateRangePicker widget ko define kar rahe hain.
            class DateRangePicker extends Component {
                constructor() {
                    super(...arguments); // Parent class constructor ko call kar rahe hain.
                    this.startDate = '';
                    this.endDate = '';
                }
        
                // Start date change hone par ye method trigger hoga.
                _onStartDateChange(event) {
                    this.startDate = event.target.value; // Start date ko capture kar rahe hain.
                }
        
                // End date change hone par ye method trigger hoga.
                _onEndDateChange(event) {
                    this.endDate = event.target.value; // End date ko capture kar rahe hain.
                }
        
                // Custom rendering method jo template ko render karega.
                render() {
                    this.$el.html(core.qweb.render('my_module.DateRangePickerTemplate', {
                        startDate: this.startDate,
                        endDate: this.endDate,
                    }));
                }
            }
        
            // Action registry mein widget ko register kar rahe hain.
            core.action_registry.add('my_module.date_range_picker', DateRangePicker);
            return DateRangePicker;
        });
                </pre>

    <h3 class="subsection-title">2. Use Proper Naming Conventions</h3>
    <p>Odoo JavaScript code mein proper naming conventions ka use karna bahut zaroori hai. Ye aapke code ko readable aur
      understandable banaata hai, especially jab aap team ke sath kaam karte hain.</p>
    <p><strong>Best Practices for Naming:</strong></p>
    <ul>
      <li><strong>Variables and Functions:</strong> Clear aur descriptive names rakhen. Jaise handleFormSubmit ya
        getDataFromServer aise names behtar hain.</li>
      <li><strong>Components and Widgets:</strong> Component ya widget ka naam uske functionality se related hona
        chahiye. Example: SalesReportWidget ya CustomerDetailsComponent.</li>
      <li><strong>CSS Classes:</strong> CSS classes mein bhi descriptive aur consistent naming ka use karein. Example:
        .product-card, .customer-details.</li>
    </ul>
    <p><strong>Example of Naming Convention in Odoo JS:</strong></p>
    <pre class="language-javascript">
        odoo.define('my_module.CustomerDetailsComponent', function (require) {
            const { Component } = require('owl');
            const { on } = require('web.core'); // Event handling ke liye method ko import kar rahe hain.
        
            class CustomerDetailsComponent extends Component {
                // Constructor mein basic setup kar rahe hain.
                constructor() {
                    super(...arguments);
                    this.customerName = '';
                }
        
                // Customer name update hone par ye method call hota hai.
                updateCustomerName(event) {
                    this.customerName = event.target.value;
                }
        
                // Render method for displaying customer details.
                render() {
                    this.$el.html(core.qweb.render('my_module.CustomerDetailsTemplate', {
                        customerName: this.customerName,
                    }));
                }
            }
        
            return CustomerDetailsComponent;
        });
                </pre>

    <h3 class="subsection-title">3. Follow DRY Principle (Don’t Repeat Yourself)</h3>
    <p>DRY principle ka matlab hai ki aapko apne code mein repetition avoid karni chahiye. Agar ek hi functionality
      multiple jagah repeat ho rahi ho, to usko ek function ya method mein rakhna chahiye aur use karna chahiye.</p>
    <p><strong>Example: Avoiding Redundancy</strong></p>
    <pre class="language-javascript">
        odoo.define('my_module.DataValidator', function (require) {
            const { Component } = require('owl');
        
            // Reusable function to validate data
            function validateData(data) {
                if (!data || data === '') {
                    throw new Error('Data cannot be empty');
                }
            }
        
            class DataEntryComponent extends Component {
                constructor() {
                    super(...arguments);
                }
        
                onSubmit() {
                    try {
                        validateData(this.data); // Reusing the validateData function
                        console.log('Data submitted successfully');
                    } catch (error) {
                        console.log(error.message);
                    }
                }
            }
        
            return DataEntryComponent;
        });
                </pre>

    <h3 class="subsection-title">4. Error Handling and Logging</h3>
    <p>Code likhte waqt proper error handling aur logging ka dhyan rakhen. Jab bhi aap asynchronous operations (like RPC
      calls) ya user interactions ke saath kaam karte hain, to proper error handling zaroori hota hai.</p>
    <p><strong>Best Practices for Error Handling:</strong></p>
    <ul>
      <li><strong>Try-Catch Blocks:</strong> Agar aap async operations kar rahe hain, to try-catch blocks ka use karein.
      </li>
      <li><strong>Console Logging:</strong> Development mein console logs ka use karke aap apne code ko easily debug kar
        sakte hain.</li>
    </ul>
    <p><strong>Example: Error Handling and Logging in Odoo JS</strong></p>
    <pre class="language-javascript">
        odoo.define('my_module.DataFetcher', function (require) {
            const rpc = require('web.rpc'); // RPC module ko import kar rahe hain.
            const { Component } = require('owl');
        
            class DataFetcher extends Component {
                constructor() {
                    super(...arguments);
                }
        
                async fetchData() {
                    try {
                        const result = await rpc.query({
                            model: 'res.partner',
                            method: 'search_read',
                            args: [[]],
                        });
                        console.log('Data fetched successfully:', result); // Logging the fetched data
                    } catch (error) {
                        console.error('Error fetching data:', error); // Logging the error
                        alert('Something went wrong!'); // User ko alert show kar rahe hain.
                    }
                }
            }
        
            return DataFetcher;
        });
                </pre>

    <h3 class="subsection-title">5. Minimize Direct DOM Manipulation</h3>
    <p>Odoo mein direct DOM manipulation ko avoid karna chahiye, especially jab aap Owl components ka use kar rahe ho.
      Owl already rendering aur updates ke liye ek efficient system provide karta hai, isliye aapko manual DOM
      manipulation ki zarurat nahi hoti.</p>
    <p><strong>Why Avoid Direct DOM Manipulation?</strong></p>
    <ul>
      <li><strong>Efficiency:</strong> Direct DOM manipulation se performance issues ho sakte hain, especially jab large
        datasets ke saath kaam karte ho.</li>
      <li><strong>Maintainability:</strong> Agar aap manual DOM updates karte hain, to aapke code ko samajhna aur
        maintain karna difficult ho sakta hai.</li>
    </ul>
    <p><strong>Example: Avoiding Direct DOM Manipulation</strong></p>
    <pre class="language-javascript">
          odoo.define('my_module.UserListComponent', function (require) {
              const { Component } = require('owl');
              const { on } = require('web.core');
          
              class UserListComponent extends Component {
                  constructor() {
                      super(...arguments);
                      this.users = [];
                  }
          
                  async fetchUsers() {
                      try {
                          const result = await this._rpc({
                              model: 'res.users',
                              method: 'search_read',
                              args: [[]],
                          });
                          this.users = result; // Direct DOM manipulation ke bajaye data ko state mein update kar rahe hain.
                          this.render(); // Render method ko call kar rahe hain jo DOM ko efficiently update karega.
                      } catch (error) {
                          console.error('Error fetching users:', error);
                      }
                  }
          
                  render() {
                      // Owl component ka render method use kar rahe hain, jo efficient rendering handle karega.
                      this.$el.html(this._renderTemplate(this.users)); 
                  }
              }
          
              return UserListComponent;
          });
                  </pre>
  </div>

































  <div class="content">
    <!-- Section Title: Code Structure and Organization in Odoo JavaScript Development -->
    <h1 class="section-title">Code Structure and Organization in Odoo JavaScript Development</h1>

    <!-- Introduction -->
    <p>Odoo JavaScript development mein code ko achhe se structure aur organize karna bahut zaroori hota hai, taki code
      maintainable, readable, aur scalable ho. JavaScript ke latest features ka use karna aur Owl component system ko
      samajhna bhi zaroori hai, jo Odoo mein front-end development ke liye use hota hai.</p>

    <p>Is section mein hum Odoo JavaScript code ka structure kaise organize karein, ES6+ features kaise use karein, aur
      Owl component mein code modularization ko kaise implement karein, ye sab details mein samjhenge.</p>

    <!-- Section 1: Organizing and Structuring JavaScript Code in Odoo -->
    <h2 class="subsection-title">1. Organizing and Structuring JavaScript Code in Odoo</h2>
    <p>JavaScript code ko Odoo mein organize karna kaafi important hota hai, taki aap asaani se naye features add kar
      sakein aur bugs ko efficiently fix kar sakein. Aapko modularization, clear folder structure, aur naming
      conventions ka use karna chahiye.</p>

    <!-- Folder Structure Explanation -->
    <p><strong>Folder Structure for Odoo JS Code</strong></p>
    <pre><code class="language-css">
              my_module/
              ├── static/
              │   ├── src/
              │   │   ├── js/
              │   │   │   ├── components/
              │   │   │   │   ├── UserList.js
              │   │   │   │   └── ChartWidget.js
              │   │   │   ├── models/
              │   │   │   │   ├── UserModel.js
              │   │   │   └── main.js
              │   └── views/
              │       └── assets.xml
              ├── __manifest__.py
                      </code></pre>

    <!-- Explanation of Folder Structure -->
    <p><strong>Explanation:</strong></p>
    <ul>
      <li><strong>components/</strong>: Jahan aapke custom Owl components store hote hain.</li>
      <li><strong>models/</strong>: Agar aapko data models define karna ho, to ye folder unke liye hai.</li>
      <li><strong>main.js</strong>: Ye entry point hota hai, jahan se aap apne JS files ko import karte hain.</li>
    </ul>

    <p><strong>Best Practices for Organizing Code:</strong></p>
    <ul>
      <li><strong>Small Files and Components:</strong> Code ko small aur logically separate files mein rakhna chahiye.
        Jaise UserList.js ko ChartWidget.js se alag rakhen.</li>
      <li><strong>Single Responsibility Principle (SRP):</strong> Har component ya module ko ek single responsibility
        deni chahiye.</li>
      <li><strong>Reusability:</strong> Aapke components aur functions reusable hone chahiye, taki unhe multiple places
        pe use kiya ja sake.</li>
    </ul>

    <!-- Section 2: Using ES6+ Features -->
    <h2 class="subsection-title">2. Using ES6+ Features (import/export, Promises, Async-Await)</h2>
    <p>ES6+ features ka use karke aap apne Odoo JavaScript code ko zyada modern, readable, aur maintainable bana sakte
      hain. Odoo mein JavaScript ke liye ES6+ features ka support hota hai.</p>

    <!-- Part a: Import and Export -->
    <p><strong>a. Import and Export (Module System)</strong></p>
    <p>JavaScript modules ka use karke aap apne code ko better organize kar sakte hain. Aap import aur export keywords
      ka use karke apne functions aur components ko alag-alag files mein organize kar sakte hain.</p>

    <!-- Code Example: Using import and export -->
    <pre><code class="language-javascript">
                      // File: models/UserModel.js
                      export const getUserData = async () =>  {
                          const response = await fetch('/get-user-data');
                          const data = await response.json();
                          return data;
                      };
              
                      // File: components/UserList.js
                      import { getUserData } from '../models/UserModel';
              
                      class UserList extends Component {
                          constructor() {
                              super(...arguments);
                              this.users = [];
                          }
              
                          async fetchUserData() {
                              this.users = await getUserData(); // User data fetch kar rahe hain
                              this.render();
                          }
                      }
                      </code></pre>

    <!-- Explanation of Import and Export -->
    <p><strong>Explanation:</strong></p>
    <ul>
      <li><strong>export:</strong> UserModel.js mein function ko export kiya gaya hai, jise dusri files mein import kiya
        ja sakta hai.</li>
      <li><strong>import:</strong> UserList.js mein getUserData function ko import karke use kiya gaya hai.</li>
    </ul>

    <!-- Part b: Promises and Async-Await -->
    <p><strong>b. Promises and Async-Await</strong></p>
    <p>Async-Await ka use karke aap asynchronous code ko sync jaisa likh sakte hain, jo code ko zyada readable aur
      error-free banaata hai.</p>

    <!-- Code Example: Using Async-Await with Promises -->
    <pre><code class="language-javascript">
              // Using async-await for asynchronous code
              odoo.define('my_module.DataFetcher', function (require) {
                  const rpc = require('web.rpc');  // RPC module import kiya gaya hai
                  const { Component } = require('owl');
              
                  class DataFetcher extends Component {
                      constructor() {
                          super(...arguments);
                      }
              
                      // Data fetch karne ke liye async-await ka use
                      async fetchData() {
                          try {
                              const result = await rpc.query({
                                  model: 'res.partner',
                                  method: 'search_read',
                                  args: [[]],
                              });
                              console.log('Fetched Data:', result); // Data ko log kar rahe hain
                          } catch (error) {
                              console.error('Error Fetching Data:', error);
                          }
                      }
                  }
              
                  return DataFetcher;
              });
                      </code></pre>

    <!-- Explanation of Async-Await with Promises -->
    <p><strong>Explanation:</strong></p>
    <ul>
      <li><strong>async-await:</strong> Yahan humne fetchData method mein async-await ka use kiya hai, jo ki RPC call ko
        synchronously handle karta hai.</li>
      <li><strong>try-catch:</strong> Errors ko handle karne ke liye try-catch ka use kiya gaya hai, taki agar kuch
        galat ho to error ko handle kiya ja sake.</li>
    </ul>

    <!-- Section 3: Modularizing JS Code and Reusability in Owl Component -->
    <h2 class="subsection-title">3. Modularizing JS Code and Reusability in Owl Component</h2>
    <p>Owl ek component-based architecture follow karta hai, jo aapko code ko modularize karne ki suvidha deta hai. Aap
      apne code ko chhote-chhote components mein divide kar sakte hain jo apne aap mein self-contained hote hain aur
      dusre parts se independent hote hain.</p>

    <p><strong>Why Modularization Important Hai?</strong></p>
    <ul>
      <li><strong>Separation of Concerns:</strong> Har component apne specific task ko handle karta hai, jo code ko
        simple aur understandable banaata hai.</li>
      <li><strong>Reusability:</strong> Ek component ko aap multiple places par reuse kar sakte hain bina naye code
        likhe.</li>
      <li><strong>Scalability:</strong> Jab aapka project grow karta hai, to modularization se naye features add karna
        asaan ho jata hai.</li>
    </ul>

    <!-- Code Example: Modularizing Code in Owl Component -->
    <pre><code class="language-javascript">
              // File: components/ChartComponent.js
              odoo.define('my_module.ChartComponent', function (require) {
                  const { Component } = require('owl');
                  const { on } = require('web.core');
              
                  class ChartComponent extends Component {
                      constructor() {
                          super(...arguments);
                          this.chartData = this.props.chartData;
                      }
              
                      // Render chart data as per passed props
                      render() {
                          // Render method ko call kar rahe hain jo template ko render karega
                          this.$el.html(core.qweb.render('my_module.ChartTemplate', {
                              chartData: this.chartData,
                          }));
                      }
                  }
              
                  return ChartComponent;
              });
              
              // File: components/UserListComponent.js
              odoo.define('my_module.UserListComponent', function (require) {
                  const { Component } = require('owl');
                  const ChartComponent = require('my_module.ChartComponent'); // Importing Chart component
              
                  class UserListComponent extends Component {
                      constructor() {
                          super(...arguments);
                          this.users = [];
                      }
            
                      // Fetch user data
                      async fetchUserData() {
                          const result = await this._rpc({
                              model: 'res.users',
                              method: 'search_read',
                              args: [[]],
                          });
                          this.users = result;
                          this.render();
                      }
                      
                      // Render user list and chart
                      render() {
                          this.$el.html(core.qweb.render('my_module.UserListTemplate', {
                              users: this.users,
                          }));
                      
                          // Reusing ChartComponent for displaying user stats
                          new ChartComponent(this, { chartData: this.users });
                      }
                  }
              
                  return UserListComponent;
              });
                      </code></pre>

    <!-- Explanation of Modularization Example -->
    <p><strong>Explanation:</strong></p>
    <ul>
      <li><strong>ChartComponent:</strong> Ek Chart component ko UserListComponent mein reuse kiya gaya hai, jisme user
        data pass karke chart ko render kiya ja raha hai.</li>
      <li><strong>Reusability:</strong> UserListComponent aur ChartComponent dono reusable hain, jise aap alag-alag
        places pe use kar sakte hain.</li>
      <li><strong>Modularization:</strong> Code ko modular components mein divide kiya gaya hai, jisse code ko maintain
        karna aur scale karna asaan ho jata hai.</li>
    </ul>

    <!-- Conclusion -->
    <p>Is section mein humne Odoo JavaScript development mein code structure, modularization, aur ES6+ features ka use
      samjha. Aapke code ko achhe se organize karna aur components ko modular banaye rakhna aapke project ko
      maintainable aur scalable banata hai. Jab aap Odoo mein JavaScript development karte hain, to in practices ko apna
      kar aap apne code ko zyada efficient aur error-free bana sakte hain.</p>

  </div>































  <div class="content">
    <h1>Explanation:</h1>
    <p><strong>Modularization:</strong> Yahan pe humne <code>ChartComponent</code> ko <code>UserListComponent</code>
      mein reuse kiya hai. Isse code ka duplication kam hota hai aur maintain karna asaan ho jata hai.</p>
    <p><strong>Props:</strong> <code>ChartComponent</code> mein chart data ko props ke roop mein pass kiya gaya hai, jo
      ki component ko dynamic banata hai.</p>
    <p><strong>Code Reusability:</strong> Aap same <code>ChartComponent</code> ko different places par use kar sakte
      hain.</p>

    <h2 class="section-title">Conclusion</h2>
    <p>Odoo JavaScript development mein modularization, ES6+ features (<code>import/export</code>,
      <code>async-await</code>, <code>promises</code>), aur Owl component structure ka use karna aapke code ko clean,
      efficient, aur maintainable banaata hai.
    </p>

    <ul>
      <li><strong>Code Structure</strong> ko organize karna bahut zaroori hai, taki aapka project easily scale ho sake.
      </li>
      <li><strong>ES6+</strong> features ka use karke aap apne code ko modern aur readable bana sakte hain.</li>
      <li><strong>Modularization</strong> se code ka reusability barhta hai aur new features ko add karna asaan hota
        hai.</li>
    </ul>

    <h2 class="section-title">Testing and Debugging in Odoo JavaScript Development</h2>
    <p>Odoo JavaScript development mein testing aur debugging kaafi zaroori tasks hain, taki aap apne code ki quality ko
      ensure kar sakein aur efficiently issues ko resolve kar sakein. Testing aapko bugs ko detect karne mein madad
      karta hai, aur debugging se aap existing issues ko resolve kar sakte hain.</p>

    <p>Is section mein hum unit testing aur debugging techniques ke baare mein discuss karenge jo Odoo JavaScript code
      ke liye useful hote hain.</p>

    <h3 class="subsection-title">1. Setting Up Unit Tests for Odoo JS Code</h3>
    <p>Unit tests ki madad se aap apne individual functions ya modules ko test kar sakte hain, taaki aap ensure kar
      sakein ki wo expected tarike se kaam kar rahe hain. Odoo mein JavaScript code ka testing karne ke liye aap QUnit
      framework ka use kar sakte hain, jo ki Odoo ke testing suite ka part hai.</p>

    <h4 class="subsection-title">QUnit Test Setup in Odoo</h4>
    <p>Odoo mein unit tests setup karna kaafi simple hai. QUnit Odoo ke <code>web_test</code> module ke through
      available hota hai. Aapko apne module mein ek testing file create karni hoti hai aur usme apne tests define karne
      hote hain.</p>

    <h4>Example: Writing Unit Tests Using QUnit</h4>
    <p><strong>Install Testing Dependencies:</strong> Sabse pehle, ensure karein ki testing dependencies properly setup
      ho.</p>
    <pre><code class="language-xml">&lt;!-- In your __manifest__.py file --&gt; 
        'test': [
            'test/my_module_tests.js',  &lt!-- Your test file --&gt; 
        ],</code></pre>

    <h4>Create a Test File</h4>
    <p>Apne module ke <code>static/src/js/test</code> folder mein test file create karein.</p>

    <pre><code class="language-javascript">// File: static/src/js/test/my_module_tests.js
        odoo.define('my_module.tests', function (require) {
            var QUnit = require('qunit');
            var MyModule = require('my_module.MyModule');  // Import the module to be tested
        
            QUnit.module('MyModule Tests', function () {
        
                QUnit.test('should add two numbers correctly', function (assert) {
                    var result = MyModule.add(2, 3); // Testing add method
                    assert.strictEqual(result, 5, "2 + 3 should equal 5");
                });
        
                QUnit.test('should return correct user data', async function (assert) {
                    var result = await MyModule.getUserData();
                    assert.ok(result, 'User data should be fetched correctly');
                });
        
            });
        });</code></pre>

    <h4>Explanation:</h4>
    <ul>
      <li><strong>QUnit:</strong> Ye JavaScript testing framework hai jisme aap <code>QUnit.test</code> method ka use
        karke test cases likhte hain.</li>
      <li><strong>Testing a Method:</strong> Humne <code>MyModule.add(2, 3)</code> method ko test kiya hai aur
        <code>strictEqual</code> se expected value verify ki hai.
      </li>
      <li><strong>Async Test:</strong> <code>getUserData()</code> method ko async test kiya gaya hai, taki aap
        asynchronous operations ko bhi test kar sakein.</li>
    </ul>

    <p><strong>Running the Tests:</strong> Aap apne unit tests ko Odoo’s test runner ke through run kar sakte hain:</p>
    <pre><code class="language-bash">./odoo-bin --test-enable</code></pre>
  </div>



















  <div class="content">
    <h1 class="section-title">1. Custom Dashboard with Charts and Graphs</h1>
    <p>Project Overview:</p>
    <p>Is project mein, hum Odoo mein ek custom dashboard banayenge jo charts aur graphs ko display karega. Hum Owl
      components aur Chart.js (ya kisi aur charting library) ka use karenge.</p>

    <h2 class="subsection-title">Steps:</h2>
    <p>Custom Odoo Module: Sabse pehle ek custom Odoo module create karein.</p>

    <pre class="highlight"><code class="language-bash">odoo scaffold custom_dashboard_module</code></pre>

    <p>Include JavaScript Library (Chart.js): Chart.js ko apne module mein include karein jo graphs aur charts ko render
      karega.</p>

    <h3 class="subsection-title">Example: static/src/js/chart.js</h3>

    <pre class="highlight"><code class="language-javascript">
              // Odoo mein custom ChartWidget banane ke liye 'web.Widget' ko extend kiya gaya hai.
              odoo.define('custom_dashboard_module.ChartWidget', function (require) {
                  var Widget = require('web.Widget');
                  var core = require('web.core');
                  var QWeb = core.qweb;
              
                  var ChartWidget = Widget.extend({
                      // Custom widget ko ek template ki zaroorat hoti hai, jisme chart ko render kiya jayega.
                      template: 'custom_dashboard_module.ChartTemplate',
              
                      // Widget ko initialize karte waqt hum data ko pass karte hain.
                      init: function (parent, options) {
                          this._super(parent, options);
                          this.data = options.data;  // Data to plot the chart
                      },
              
                      // Jab widget start hota hai, tab hum chart ko render karte hain.
                      start: function () {
                          this.renderChart(); // Call renderChart method to draw chart
                          return this._super();
                      },
              
                      // Function to render the chart using Chart.js
                      renderChart: function () {
                          // Ye method canvas element ko get karta hai jahan pe chart render hoga
                          var ctx = this.$el[0].getContext('2d');
                          var chart = new Chart(ctx, {
                              type: 'bar',  // Yahan pe hum bar chart type use kar rahe hain
                              data: {
                                  labels: this.data.labels,  // X-axis labels
                                  datasets: [{
                                      label: 'Sales Data',  // Dataset ka label
                                      data: this.data.values,  // Y-axis values
                                      backgroundColor: 'rgba(75, 192, 192, 0.2)', // Bar color
                                      borderColor: 'rgba(75, 192, 192, 1)', // Border color
                                      borderWidth: 1
                                  }]
                              },
                              options: {
                                  scales: {
                                      y: { beginAtZero: true } // Y-axis ko zero se start karna
                                  }
                              }
                          });
                      },
                  });
              
                  return ChartWidget;  // Widget ko return karna taaki wo use ho sake
              });
                  </code></pre>

    <p>Create a Template to Display the Chart: Chart ko display karne ke liye ek QWeb template create karna hoga.</p>

    <h3 class="subsection-title">Example: views/dashboard_template.xml</h3>

    <pre class="highlight"><code class="language-xml">&lt;template id="dashboard_template"&gt; 
                  &lt;canvas id="myChart" width="400" height="400"&gt;&lt;/canvas&gt;  &lt;!-- Canvas element for chart --&gt; 
              &lt;/template&gt;</code></pre>

    <p>Integrate with Odoo Backend: Backend se data fetch karne ke liye RPC (Remote Procedure Call) ka use karein.</p>

    <h3 class="subsection-title">Example:</h3>

    <pre class="highlight"><code class="language-javascript">
              // Ajax RPC request se backend se data fetch karte hain.
              var ajax = require('web.ajax');
              ajax.jsonRpc('/my/custom/data', 'call', {}).then(function(data) {
                  // RPC se data milne par ChartWidget ko initialize karenge aur usme data pass karenge
                  var chartWidget = new ChartWidget(null, { data: data });
                  chartWidget.appendTo($('#dashboard')); // Dashboard me chart ko append karenge
              });
                  </code></pre>

    <p>Display the Dashboard: Odoo views mein widget ko integrate karein jisse dashboard user ko display ho.</p>

    <h3 class="subsection-title">Example: views/dashboard_view.xml</h3>

    <pre class="highlight"><code class="language-xml">&lt;odoo&gt; 
                  &lt;record id="view_dashboard" model="ir.ui.view"&gt; 
                      &lt;field name="name"&gt; Dashboard View&lt;/field&gt; 
                      &lt;field name="model"&gt; res.users&lt;/field&gt; 
                      &lt;field name="arch" type="xml"&gt; 
                          &lt;form&gt; 
                              &lt;div id="dashboard"&gt;&lt;/div&gt;  &lt;!-- Placeholder to display dashboard --&gt; 
                          &lt;/form&gt; 
                      &lt;/field&gt; 
                  &lt;/record&gt; 
              &lt;/odoo&gt;</code></pre>

    <p>Testing and Debugging: Module ko testing aur debugging karte waqt ensure karein ki dashboard sahi data show kar
      raha ho aur user interactions properly handle ho rahe ho.</p>

    <h1 class="section-title">2. Custom Kanban View with Dynamic Fields</h1>
    <p>Project Overview:</p>
    <p>Is project mein, aap Odoo ki Kanban view ko customize karenge jisme dynamic fields aur drag-and-drop
      functionality hogi.</p>

    <h2 class="subsection-title">Steps:</h2>
    <p>Custom Kanban View Module: Ek custom module banayein aur usme Kanban view define karein.</p>

    <h3 class="subsection-title">Define Kanban View in XML:</h3>
    <p>Kanban view ko define karte waqt dynamic fields add karein.</p>

    <h3 class="subsection-title">Example: views/kanban_view.xml</h3>

    <pre class="highlight"><code class="language-xml">&lt;odoo&gt; 
                  &lt;record id="view_custom_kanban" model="ir.ui.view"&gt; 
                      &lt;field name="name"&gt; Custom Kanban View&lt;/field&gt; 
                      &lt;field name="model"&gt; project.task&lt;/field&gt; 
                      &lt;field name="arch" type="xml"&gt; 
                          &lt;kanban&gt; 
                              &lt;templates&gt; 
                                  &lt;t t-name="kanban-box"&gt; 
                                      &lt;div class="oe_kanban_details"&gt; 
                                          &lt;field name="name"/&gt; 
                                          &lt;field name="user_id"/&gt; 
                                          &lt;!-- Dynamic field --&gt; 
                                          &lt;div class="custom_field"&gt; 
                                              &lt;field name="custom_field" options="{'widget': 'char'}"/&gt; 
                                          &lt;/div&gt; 
                                      &lt;/div&gt; 
                                  &lt;/t&gt; 
                              &lt;/templates&gt; 
                          &lt;/kanban&gt; 
                      &lt;/field&gt; 
                  &lt;/record&gt; 
              &lt;/odoo&gt;</code></pre>

    <p>Creating the Custom Widget: Owl component ka use karke custom behavior implement karna hoga, jisme drag-and-drop
      aur dynamic field updates handle kiye jayenge.</p>

    <h3 class="subsection-title">Implement the Drag-and-Drop Functionality:</h3>
    <p>JavaScript mein drag-and-drop ka feature implement karna hoga. Yahan hum Owl aur KanbanModel ka use karenge.</p>

    <h3 class="subsection-title">Example:</h3>

    <pre class="highlight"><code class="language-javascript">
              odoo.define('custom_kanban_module.DragDropKanban', function (require) {
                  var KanbanModel = require('web.KanbanModel');
                  var core = require('web.core');
                  var QWeb = core.qweb;
              
                  // Kanban view mein click event handle karna
                  KanbanModel.include({
                      events: {
                          'click .oe_kanban_box': '_onClickKanbanBox',
                      },
              
                      // Kanban box pe click hone par task update karna
                      _onClickKanbanBox: function (event) {
                          var taskId = $(event.currentTarget).data('id');
                          this._rpc({
                              model: 'project.task',
                              method: 'write',
                              args: [[taskId], { custom_field: 'New Value' }],
                          });
                      }
                  });
              });
                  </code></pre>

    <p>Testing and Debugging:</p>
    <p>Ensure karein ki drag-and-drop aur dynamic field updates sahi se kaam kar rahe hain.</p>

    <h1 class="section-title">3. Custom Form View with Inline Editing</h1>
    <p>Project Overview:</p>
    <p>Is project mein, hum form view ko customize karenge jisme inline editing ki facility hogi. User directly field ko
      edit kar sakega bina page reload kiye.</p>

    <h2 class="subsection-title">Steps:</h2>
    <p>Custom Form View Module: Ek custom module create karein aur usme ek custom form view define karein.</p>

    <h3 class="subsection-title">Define Form View in XML:</h3>
    <p>Form view mein inline editing ko enable karein.</p>

    <h3 class="subsection-title">Example: views/form_view.xml</h3>

    <pre class="highlight"><code class="language-xml">&lt;odoo&gt; 
                  &lt;record id="view_custom_form" model="ir.ui.view"&gt; 
                      &lt;field name="name"&gt; Custom Form View&lt;/field&gt; 
                      &lt;field name="model"&gt; hr.employee&lt;/field&gt; 
                      &lt;field name="arch" type="xml"&gt; 
                          &lt;form&gt; 
                              &lt;sheet&gt; 
                                  &lt;field name="name"/&gt; 
                                  &lt;field name="job_id"/&gt; 
                                  &lt;field name="department_id"/&gt; 
                                  &lt;!-- Inline editable field --&gt; 
                                  &lt;field name="custom_field" options="{'widget': 'char'}"/&gt; 
                              &lt;/sheet&gt; 
                          &lt;/form&gt; 
                      &lt;/field&gt; 
                  &lt;/record&gt; 
              &lt;/odoo&gt;</code></pre>

    <p>Implement Inline Editing in JavaScript: JavaScript mein inline editing ka behavior implement karein. Inline
      editing ko JavaScript mein implement karte waqt hum Owl aur FormView ko extend karenge taaki user directly field
      ko edit kar sake.</p>

    <p><strong>Explanation:</strong> Aapka project ka aim hai Odoo mein custom dashboard, kanban view aur form view
      create karna, jisme har feature ko user-friendly banaya jaaye. Aap JavaScript (Chart.js, Owl components) aur
      Odoo-specific XML ko combine kar rahe hain taaki dynamic, interactive views create ki ja sakein.</p>
  </div>


















  <div class="content">
    <h1 class="section-title">Odoo Architecture Overview</h1>

    <p>In this section, we will explore how to customize various features in Odoo using JavaScript and XML, focusing on
      inline editing, custom report views, and web client customization.</p>

    <h2 class="subsection-title">1. Inline Editing in Odoo</h2>

    <p>This example demonstrates how to implement inline editing in an Odoo form view using JavaScript.</p>

    <div class="highlight">
      <pre><code class="language-javascript">
            odoo.define('custom_form_module.InlineEditing', function (require) {
                // Import FormView to extend its functionality
                var FormView = require('web.FormView');
                var core = require('web.core');
            
                FormView.include({
                    // Events to listen for inline editing trigger
                    events: {
                        'click .oe_inline_edit': '_onInlineEditClick',  // Custom inline editing event
                    },
            
                    // Custom event handler for inline editing
                    _onInlineEditClick: function (event) {
                        // Get the field name from the clicked element
                        var fieldName = $(event.target).data('field');
                        
                        // Send a RPC call to update the field with a new value
                        this._rpc({
                            model: 'hr.employee',  // Model we are working with
                            method: 'write',  // RPC method to update the field
                            args: [[this.record.id], { [fieldName]: 'Updated Value' }],  // Data to update
                        }).then(function () {
                            // Optionally, you can refresh the form or show a success message
                            console.log('Field updated successfully!');
                        });
                    }
                });
            });
                        </code></pre>
    </div>

    <h3 class="subsection-title">Explanation of Code:</h3>
    <ul>
      <li><strong>FormView.include:</strong> Hum FormView ko extend kar rahe hain, jisse hum custom behavior add kar
        sakein.</li>
      <li><strong>'click .oe_inline_edit':</strong> Hum click event listen kar rahe hain jo inline edit ko trigger
        karega.</li>
      <li><strong>_onInlineEditClick:</strong> Is method mein hum selected field ko update kar rahe hain, aur RPC ka use
        karte hue backend pe changes apply kar rahe hain.</li>
      <li><strong>_rpc:</strong> Odoo ka RPC (Remote Procedure Call) ka use kar ke hum server-side method write ko call
        karte hain, jo selected field ko update kar dega.</li>
    </ul>

    <h3 class="subsection-title">Testing and Debugging:</h3>
    <ul>
      <li>Apne form view ko testing karein aur dekhein ki inline editing sahi se kaam kar raha ho.</li>
      <li>Debugging ke liye browser ke Developer Tools ka use karein, taaki aap dekh sakein ki koi errors ya issues to
        nahi aa rahe hain.</li>
    </ul>

    <h2 class="subsection-title">4. Custom Report View with Interactive Filters</h2>

    <p>Is project mein, aap ek custom report view banayenge jisme users ko interactive filters apply karne ki facility
      milegi. Yeh report view Owl components ka use karega taaki filters dynamically update ho sakein.</p>

    <h3 class="subsection-title">Steps:</h3>
    <ul>
      <li><strong>Custom Report Module:</strong> Sabse pehle ek custom module create karein jo report view aur filters
        ko manage karega.</li>
      <li><strong>Define Report View in XML:</strong> Apne module mein ek report view ko define karein aur usmein
        interactive filters add karein.</li>
    </ul>

    <div class="highlight">
      <pre><code class="language-xml">
            &lt;odoo&gt;
                &lt;record id="view_custom_report" model="ir.ui.view"&gt;
                    &lt;field name="name"&gt; Custom Report View&lt;/field&gt;
                    &lt;field name="model"&gt; sale.order&lt;/field&gt;
                    &lt;field name="arch" type="xml"&gt;
                        &lt;form&gt;
                            &lt;sheet&gt;
                                &lt;!-- Filters to apply on the report --&gt;
                                &lt;div class="filter-container"&gt;
                                    &lt;button t-on-click="applyFilter" class="oe_button"&gt; Apply Filter&lt;/button&gt;
                                &lt;/div&gt;
                                &lt;div id="report-container"&gt; &lt;/div&gt;  &lt;!-- Placeholder for the report --&gt;
                            &lt;/sheet&gt;
                        &lt;/form&gt;
                    &lt;/field&gt;
                &lt;/record&gt;
            &lt;/odoo&gt;
                        </code></pre>
    </div>

    <h3 class="subsection-title">Creating the JavaScript Widget for Interactive Filters:</h3>
    <p>Is example mein hum ek widget bana rahe hain jo filters ko handle karega aur report ko dynamically update karega.
    </p>

    <div class="highlight">
      <pre><code class="language-javascript">
            odoo.define('custom_report_module.ReportWidget', function (require) {
                var Widget = require('web.Widget');
                var core = require('web.core');
                var ajax = require('web.ajax');
            
                var ReportWidget = Widget.extend({
                    template: 'custom_report_module.ReportTemplate',
            
                    init: function (parent, options) {
                        this._super(parent, options);
                        this.filters = {};  // Initialize an empty filter object
                    },
            
                    start: function () {
                        // Set up event listeners for filters
                        this.$('.oe_button').on('click', this.applyFilter.bind(this)); // Attach apply filter function
                        return this._super();
                    },
            
                    // Apply selected filters to fetch the filtered report data
                    applyFilter: function () {
                        var filterData = this.filters;  // Use the filters selected by the user
            
                        // Make an RPC call to fetch the filtered report data from the backend
                        ajax.jsonRpc('/fetch/filtered_report', 'call', { filters: filterData })
                            .then(function (reportData) {
                                // Update the report view with the new filtered data
                                this.updateReportView(reportData);
                            }.bind(this));
                    },
            
                    // Update the report view with new data
                    updateReportView: function (data) {
                        // Render the report using the new data
                        this.$('#report-container').html(data);
                    },
                });
            
                return ReportWidget;
            });
                        </code></pre>
    </div>

    <h3 class="subsection-title">Integrate Report Widget in the View:</h3>
    <p>Apne custom report view mein ReportWidget ko integrate karein.</p>

    <div class="highlight">
      <pre><code class="language-xml">
            &lt;odoo&gt;
                &lt;record id="view_custom_report" model="ir.ui.view"&gt;
                    &lt;field name="name"&gt; Custom Report View&lt;/field&gt;
                    &lt;field name="model"&gt; sale.order&lt;/field&gt;
                    &lt;field name="arch" type="xml"&gt;
                        &lt;form&gt;
                            &lt;sheet&gt;
                                &lt;div class="filter-container"&gt;
                                    &lt;button t-on-click="applyFilter" class="oe_button"&gt; Apply Filter&lt;/button&gt;
                                &lt;/div&gt;
                                &lt;div id="report-container"&gt; &lt;/div&gt;
                            &lt;/sheet&gt;
                        &lt;/form&gt;
                    &lt;/field&gt;
                &lt;/record&gt;
            &lt;/odoo&gt;
                        </code></pre>
    </div>

    <h3 class="subsection-title">Testing and Debugging:</h3>
    <ul>
      <li>Apne report view ko test karein aur dekhein ki interactive filters sahi se kaam kar rahe hain.</li>
      <li>Developer Tools ka use karein taaki aap console errors ya issues ko trace kar sakein.</li>
    </ul>

    <h2 class="subsection-title">1. Odoo Web Client aur Dashboard ko Customize Karna</h2>

    <h3 class="subsection-title">Web Client Interface ko Customize Karna:</h3>
    <p>Is section mein hum Odoo ke web client ko customize karenge using Owl components. Hum ek custom dashboard create
      karenge.</p>

    <h3 class="subsection-title">XML View for Dashboard:</h3>

    <div class="highlight">
      <pre><code class="language-xml">
            &lt;odoo&gt;
                &lt;!-- Custom dashboard ke liye view define karna --&gt;
                &lt;record id="custom_dashboard_view" model="ir.ui.view"&gt;
                    &lt;field name="name"&gt; Custom Dashboard&lt;/field&gt;  &lt;!-- View ka naam --&gt;
                    &lt;field name="model"&gt; res.users&lt;/field&gt;  &lt;!-- Model jiske saath view connected hai --&gt;
                    &lt;field name="arch" type="xml"&gt;
                    &lt;div class="oe_dashboard"&gt;  &lt;!-- Dashboard ka container --&gt;
                        &lt;t t-call="web.basic_layout"&gt;  &lt;!-- Basic layout ko call kar rahe hain --&gt;
                            &lt;div class="custom-dashboard-container"&gt;  &lt;!-- Custom dashboard ka container --&gt;
                                &lt;!-- Dashboard ke data ko loop karna aur display karna --&gt;
                                &lt;div class="o_tile" t-if="widget.dashboard_data"&gt;
                                    &lt;t t-foreach="widget.dashboard_data" t-as="data"&gt;
                                        &lt;div class="o_tile_item"&gt;
                                            &lt;h3&gt; &lt;t t-esc="data.name"/&gt; &lt;/h3&gt;  &lt;!-- Data ka naam show karna --&gt;
                                            &lt;p&gt; &lt;t t-esc="data.value"/&gt; &lt;/p&gt;  &lt;!-- Data ki value show karna --&gt;
                                        &lt;/div&gt;
                                    &lt;/t&gt;
                                &lt;/div&gt;
                            &lt;/div&gt;
                        &lt;/t&gt;
                    &lt;/div&gt;
                &lt;/field&gt;
            &lt;/record&gt;
        &lt;/odoo&gt;
                    </code></pre>
    </div>

  </div>

















  <div class="content">
    <!-- Explanation for Task Model -->
    <div class="section-title">Explanation:</div>
    <p>
      <strong>Task Model:</strong> Humne task.manager naam ka model define kiya hai jisme 3 fields hain: name,
      description, aur state.
      state field task ke status ko track karega (New, In Progress, Completed).
    </p>

    <!-- Python Controller Code -->
    <div class="subsection-title">2. Python Controller (controllers/main.py):</div>
    <pre class="highlight"><code class="language-python">
          from odoo import http
          from odoo.http import request
          
          # Controller banate hain jo tasks ko handle karega
          class TaskController(http.Controller):
          
              # Task ko get karne ke liye API route
              @http.route('/task_manager/tasks', type='json', auth="public", methods=['GET'], csrf=False)
              def get_tasks(self):
                  tasks = request.env['task.manager'].search([])  # Sabhi tasks ko fetch karna
                  return [{'id': task.id, 'name': task.name, 'description': task.description, 'state': task.state} for task in tasks]
          
              # Task ko create karne ke liye API route
              @http.route('/task_manager/task', type='json', auth="public", methods=['POST'], csrf=False)
              def create_task(self, **kwargs):
                  # Task ko create karte hain aur response mein return karte hain
                  task = request.env['task.manager'].create({
                      'name': kwargs.get('name'),
                      'description': kwargs.get('description'),
                      'state': kwargs.get('state', 'new')  # Default state 'new'
                  })
                  return {'id': task.id, 'name': task.name, 'description': task.description, 'state': task.state}
              
              # Task ko update karne ke liye API route
              @http.route('/task_manager/task/update', type='json', auth="public", methods=['POST'], csrf=False)
              def update_task(self, task_id, state):
                  task = request.env['task.manager'].browse(task_id)  # Task ko find karte hain
                  if task:
                      task.write({'state': state})  # Task ka state update karte hain
                      return {'id': task.id, 'name': task.name, 'description': task.description, 'state': task.state}
                  return {'error': 'Task not found'}  # Agar task nahi milta toh error return karte hain
              
              # Task ko delete karne ke liye API route
              @http.route('/task_manager/task/delete', type='json', auth="public", methods=['POST'], csrf=False)
              def delete_task(self, task_id):
                  task = request.env['task.manager'].browse(task_id)  # Task ko find karte hain
                  if task:
                      task.unlink()  # Task ko delete karte hain
                      return {'status': 'Task deleted successfully'}  # Success message return karte hain
                  return {'error': 'Task not found'}  # Agar task nahi milta toh error return karte hain
              </code></pre>

    <!-- Explanation of Controller -->
    <div class="section-title">Explanation:</div>
    <p>
      <strong>Controller:</strong> Humne ek controller banaya hai jo tasks ko fetch (GET), create (POST), update (POST),
      aur delete (POST) karne ke liye API routes define karta hai.
    </p>
    <p>
      <strong>CRUD Operations:</strong> create_task, update_task, aur delete_task functions tasks ko backend mein handle
      karte hain aur frontend ko response return karte hain.
    </p>

    <!-- Frontend - Owl Widget -->
    <div class="subsection-title">Step 3: Frontend - Owl Widget</div>
    <p>
      Ab hum Owl Framework ka use karte hue ek custom widget banayenge jo backend se data fetch karega aur tasks ko
      dynamically display karega.
    </p>

    <!-- JavaScript Widget Code -->
    <div class="subsection-title">1. JavaScript Widget (static/src/js/task_widget.js):</div>
    <pre class="highlight"><code class="language-javascript">
          odoo.define('task_manager.TaskWidget', function (require) {
              "use strict";
          
              var Widget = require('web.Widget');  // Odoo ka base Widget class import kar rahe hain
              var ajax = require('web.ajax');  // AJAX module ko import kar rahe hain backend se data fetch karne ke liye
          
              var TaskWidget = Widget.extend({
                  template: 'task_manager.TaskTemplate',  // Humara task widget template jo HTML ko define karega
          
                  // Jab widget start hoga, tab hum tasks ko fetch karenge
                  start: function () {
                      this._fetchTasks();  // Tasks ko fetch karne ke liye method call karte hain
                      return this._super();  // Parent class ka start method bhi call karte hain
                  },
          
                  // Backend se tasks ko fetch karne ka method
                  _fetchTasks: function () {
                      var self = this;
                      ajax.jsonRpc('/task_manager/tasks', 'call', {}).then(function (data) {
                          if (data) {
                              // Agar data milta hai, toh tasks ko display karenge
                              self.$('.task-list').empty();  // Pehle se present tasks ko clear karenge
                              data.forEach(function (task) {
                                  // Har task ke liye ek task item create karenge
                                  self.$('.task-list').append(
                                      '&lt;div class="task-item" data-id="' + task.id + '"&gt; ' +
                                      '&lt;p&gt; &lt;strong&gt; ' + task.name + '&lt;/strong&gt; &lt;/p&gt; ' +
                                      '&lt;p&gt; ' + task.description + '&lt;/p&gt; ' +
                                      '&lt;p&gt; State: ' + task.state + '&lt;/p&gt; ' +
                                      '&lt;button class="delete-btn"&gt; Delete&lt;/button&gt; ' +
                                      '&lt;button class="update-btn"&gt; Update&lt;/button&gt; ' +
                                      '&lt;/div&gt; '
                                  );
                              });
                          }
                      });
                  },
          
                  // Task ko update karne ka method
                  _updateTask: function (taskId, state) {
                      var self = this;
                      ajax.jsonRpc('/task_manager/task/update', 'call', {
                          'task_id': taskId,
                          'state': state
                      }).then(function (data) {
                          self._fetchTasks();  // Task update hone ke baad, tasks ko dubara fetch karenge
                      });
                  },
          
                  // Task ko delete karne ka method
                  _deleteTask: function (taskId) {
                      var self = this;
                      ajax.jsonRpc('/task_manager/task/delete', 'call', {
                          'task_id': taskId
                      }).then(function (data) {
                          self._fetchTasks();  // Task delete hone ke baad, tasks ko dubara fetch karenge
                      });
                  },
          
                  // User ke actions ko handle karte hain (delete aur update buttons pe click)
                  events: {
                      'click .delete-btn': function (e) {
                          var taskId = $(e.currentTarget).closest('.task-item').data('id');  // Task ka ID fetch karte hain
                          this._deleteTask(taskId);  // Task ko delete karte hain
                      },
                      'click .update-btn': function (e) {
                          var taskId = $(e.currentTarget).closest('.task-item').data('id');  // Task ka ID fetch karte hain
                          var newState = prompt("Enter new state (new, in_progress, completed):");  // User se naya state input lete hain
                          this._updateTask(taskId, newState);  // Task ke state ko update karte hain
                      }
                  }
              });
          
              return TaskWidget;  // TaskWidget ko return karte hain jise hum template mein use karenge
          });
              </code></pre>

    <!-- Explanation of Owl Widget -->
    <div class="section-title">Explanation:</div>
    <p>
      <strong>Events:</strong> Humne events object mein do actions define kiye hain:
    <ul>
      <li><strong>Delete button:</strong> Jab user Delete button pe click karega, toh task ko delete karenge. taskId ko
        use karke backend ko call karenge aur task ko delete karenge.</li>
      <li><strong>Update button:</strong> Jab user Update button pe click karega, toh ek prompt box show hoga jisme user
        task ka naya state (New, In Progress, Completed) enter karega. Us state ko backend mein update karenge.</li>
    </ul>
    </p>
    <p>
      <strong>Task Widget:</strong> Humne ek custom TaskWidget banaya hai jo tasks ko display karega aur user ko CRUD
      (Create, Read, Update, Delete) operations provide karega.
    </p>
  </div>



</body>



</html>